<!DOCTYPE HTML>
<html lang="ja" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CHIRIMEN Raspberry Pi Zero W チュートリアル</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/menu-bar.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> チュートリアル概要</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_1-1.html"><strong aria-hidden="true">1.1.</strong> CHIRIMEN について</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_1-1-1.html"><strong aria-hidden="true">1.1.1.</strong> CHIRIMEN コミュニティ</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_1-2.html"><strong aria-hidden="true">1.2.</strong> Raspberry Pi について</a></li><li class="chapter-item expanded "><a href="chapter_1-3.html"><strong aria-hidden="true">1.3.</strong> JavaScript の基礎</a></li><li class="chapter-item expanded "><a href="chapter_1-4.html"><strong aria-hidden="true">1.4.</strong> 良く使う情報へのリンク</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> 機材準備と Wi-Fi への接続</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_2-1.html"><strong aria-hidden="true">2.1.</strong> ステップ0（機材準備）</a></li><li class="chapter-item expanded "><a href="chapter_2-2.html"><strong aria-hidden="true">2.2.</strong> ステップ1（ターミナル接続）</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_2-2-1.html"><strong aria-hidden="true">2.2.1.</strong> Note. CLI操作について</a></li><li class="chapter-item expanded "><a href="chapter_2-2-2.html"><strong aria-hidden="true">2.2.2.</strong> Note. pi4 の利用方法</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_2-3.html"><strong aria-hidden="true">2.3.</strong> ステップ2（Wi-Fi設定）</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Hello Real World（Lチカを実行する）</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_3-1.html"><strong aria-hidden="true">3.1.</strong> 配線</a></li><li class="chapter-item expanded "><a href="chapter_3-2.html"><strong aria-hidden="true">3.2.</strong> プログラムを書く</a></li><li class="chapter-item expanded "><a href="chapter_3-3.html"><strong aria-hidden="true">3.3.</strong> 実行する</a></li><li class="chapter-item expanded "><a href="chapter_3-4.html"><strong aria-hidden="true">3.4.</strong> コードを読む</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">4.</strong> GPIOを試す</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_4-1.html"><strong aria-hidden="true">4.1.</strong> GPIOを理解する</a></li><li class="chapter-item expanded "><a href="chapter_4-2.html"><strong aria-hidden="true">4.2.</strong> GPIOを出力</a></li><li class="chapter-item expanded "><a href="chapter_4-3.html"><strong aria-hidden="true">4.3.</strong> GPIOを入力（onchange）</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_4-3-1.html"><strong aria-hidden="true">4.3.1.</strong> onchange コードを読む</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_4-4.html"><strong aria-hidden="true">4.4.</strong> GPIOを入力（ポーリング）</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_4-4-1.html"><strong aria-hidden="true">4.4.1.</strong> ポーリングコードを読む</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_4-5.html"><strong aria-hidden="true">4.5.</strong> GPIOセンサーを複数同時に使う</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_4-5-1.html"><strong aria-hidden="true">4.5.1.</strong> Lチカのコードを書き換える</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">5.</strong> I2Cデバイスを試す</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_5-1.html"><strong aria-hidden="true">5.1.</strong> I2Cを理解する</a></li><li class="chapter-item expanded "><a href="chapter_5-2.html"><strong aria-hidden="true">5.2.</strong> SHT30編</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_5-2-1.html"><strong aria-hidden="true">5.2.1.</strong> I2Cセンサー(SHT30)の認識を確認する</a></li><li class="chapter-item expanded "><a href="chapter_5-2-2.html"><strong aria-hidden="true">5.2.2.</strong> SHT30 のコード取得と実行</a></li><li class="chapter-item expanded "><a href="chapter_5-2-3.html"><strong aria-hidden="true">5.2.3.</strong> SHT30 のコードを読む</a></li><li class="chapter-item expanded "><a href="chapter_5-2-4.html"><strong aria-hidden="true">5.2.4.</strong> SHT30 のコードの詳細解説</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_5-3.html"><strong aria-hidden="true">5.3.</strong> ADT7410編</a></li><li class="chapter-item expanded "><a href="chapter_5-4.html"><strong aria-hidden="true">5.4.</strong> GPIO と I2Cセンサーを組み合わせる</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">6.</strong> IoTを試す</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_6-1.html"><strong aria-hidden="true">6.1.</strong> 遠隔LEDコントロール</a></li><li class="chapter-item expanded "><a href="chapter_6-2.html"><strong aria-hidden="true">6.2.</strong> PiZero サンプルコードの実行</a></li><li class="chapter-item expanded "><a href="chapter_6-3.html"><strong aria-hidden="true">6.3.</strong> PC サンプルコードの実行</a></li><li class="chapter-item expanded "><a href="chapter_6-4.html"><strong aria-hidden="true">6.4.</strong> 自分専用チャンネルで制御</a></li><li class="chapter-item expanded "><a href="chapter_6-5.html"><strong aria-hidden="true">6.5.</strong> PiZero 側のコードを読む</a></li><li class="chapter-item expanded "><a href="chapter_6-6.html"><strong aria-hidden="true">6.6.</strong> PC 側のコードを読む</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_7.html"><strong aria-hidden="true">7.</strong> 常駐プログラム化する</a></li><li class="chapter-item expanded "><a href="chapter_8.html"><strong aria-hidden="true">8.</strong> 他のいろいろなデバイスを試してみる</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_8-1.html"><strong aria-hidden="true">8.1.</strong> 応用センサーキットの使い方</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_8-1-1.html"><strong aria-hidden="true">8.1.1.</strong> 単体で動作確認できるセンサー</a></li><li class="chapter-item expanded "><a href="chapter_8-1-2.html"><strong aria-hidden="true">8.1.2.</strong> 人感センサー</a></li><li class="chapter-item expanded "><a href="chapter_8-1-3.html"><strong aria-hidden="true">8.1.3.</strong> Neopixel LED</a></li><li class="chapter-item expanded "><a href="chapter_8-1-4.html"><strong aria-hidden="true">8.1.4.</strong> アナログセンサー</a></li><li class="chapter-item expanded "><a href="chapter_8-1-5.html"><strong aria-hidden="true">8.1.5.</strong> サーボモーター</a></li><li class="chapter-item expanded "><a href="chapter_8-1-6.html"><strong aria-hidden="true">8.1.6.</strong> DCモーター（MX1508利用）</a></li><li class="chapter-item expanded "><a href="chapter_8-1-7.html"><strong aria-hidden="true">8.1.7.</strong> DCモーター（PWM駆動）</a></li><li class="chapter-item expanded "><a href="chapter_8-1-8.html"><strong aria-hidden="true">8.1.8.</strong> RaspberryPi のカメラの注意点</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="chapter_9.html"><strong aria-hidden="true">9.</strong> 付録(予備知識)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_9-1.html"><strong aria-hidden="true">9.1.</strong> CHIRIMEN ブラウザー版との差異</a></li><li class="chapter-item expanded "><a href="chapter_9-2.html"><strong aria-hidden="true">9.2.</strong> CHIRIMEN環境の任意のディレクトリへのセットアップ</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_10.html"><strong aria-hidden="true">10.</strong> 共通資料集</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_10-1.html"><strong aria-hidden="true">10.1.</strong> CHIRIMEN</a></li><li class="chapter-item expanded "><a href="chapter_10-2.html"><strong aria-hidden="true">10.2.</strong> ハードウェア・デバイス</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_10-2-1.html"><strong aria-hidden="true">10.2.1.</strong> LED</a></li><li class="chapter-item expanded "><a href="chapter_10-2-2.html"><strong aria-hidden="true">10.2.2.</strong> ブレッドボード</a></li><li class="chapter-item expanded "><a href="chapter_10-2-3.html"><strong aria-hidden="true">10.2.3.</strong> 抵抗値の読み方</a></li><li class="chapter-item expanded "><a href="chapter_10-2-4.html"><strong aria-hidden="true">10.2.4.</strong> MOSFETによる大電力制御</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_10-3.html"><strong aria-hidden="true">10.3.</strong> JavaScript</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_10-3-1.html"><strong aria-hidden="true">10.3.1.</strong> JavaScriptコード・ライブラリの読み込み</a></li><li class="chapter-item expanded "><a href="chapter_10-3-2.html"><strong aria-hidden="true">10.3.2.</strong> 非同期処理</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_10-4.html"><strong aria-hidden="true">10.4.</strong> GPIO</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_10-4-1.html"><strong aria-hidden="true">10.4.1.</strong> GPIOポートの初期化と出力処理</a></li><li class="chapter-item expanded "><a href="chapter_10-4-2.html"><strong aria-hidden="true">10.4.2.</strong> GPIOPortの入力処理（onchange）</a></li><li class="chapter-item expanded "><a href="chapter_10-4-3.html"><strong aria-hidden="true">10.4.3.</strong> GPIOPortの入力処理（ポーリング）</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_10-5.html"><strong aria-hidden="true">10.5.</strong> I2C</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_10-5-1.html"><strong aria-hidden="true">10.5.1.</strong> 各種ボードの I2C端子について</a></li><li class="chapter-item expanded "><a href="chapter_10-5-2.html"><strong aria-hidden="true">10.5.2.</strong> I2Cの詳細情報とポイント</a></li><li class="chapter-item expanded "><a href="chapter_10-5-3.html"><strong aria-hidden="true">10.5.3.</strong> WebI2C とデバイスドライバ</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_10-6.html"><strong aria-hidden="true">10.6.</strong> IoT</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_10-6-1.html"><strong aria-hidden="true">10.6.1.</strong> webSocketとpub/sub services</a></li><li class="chapter-item expanded "><a href="chapter_10-6-2.html"><strong aria-hidden="true">10.6.2.</strong> relayService</a></li><li class="chapter-item expanded "><a href="chapter_10-6-3.html"><strong aria-hidden="true">10.6.3.</strong> リアルタイム性</a></li><li class="chapter-item expanded "><a href="chapter_10-6-4.html"><strong aria-hidden="true">10.6.4.</strong> relayServer.js</a></li><li class="chapter-item expanded "><a href="chapter_10-6-5.html"><strong aria-hidden="true">10.6.5.</strong> プログラムの流れ</a></li><li class="chapter-item expanded "><a href="chapter_10-6-6.html"><strong aria-hidden="true">10.6.6.</strong> セキュリティ</a></li><li class="chapter-item expanded "><a href="chapter_10-6-7.html"><strong aria-hidden="true">10.6.7.</strong> Node.jsでの利用</a></li><li class="chapter-item expanded "><a href="chapter_10-6-8.html"><strong aria-hidden="true">10.6.8.</strong> Webhooks</a></li><li class="chapter-item expanded "><a href="chapter_10-6-9.html"><strong aria-hidden="true">10.6.9.</strong> IoTクラウドサービス</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CHIRIMEN Raspberry Pi Zero W チュートリアル</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/chirimen-oh/chirimen.org" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chirimen-チュートリアル概要"><a class="header" href="#chirimen-チュートリアル概要">CHIRIMEN チュートリアル概要</a></h1>
<p><img src="./imgs/chirimen_hello.jpg" alt="CHIRIMEN Hello World" /></p>
<p>CHIRIMEN Raspberry Pi Zero 版を用いたIoT実習資料です。</p>
<p>開発環境に Raspberry Pi Zero W を使い、開発言語に JavaScript を用いて、様々なセンサーやアクチュエーターを動かし、IoTプロトタイピングを可能にします。</p>
<p>概要では <strong>CHIRIMEN / RaspberryPi / JavaScript</strong> について解説します。</p>
<p>既に CHIRIMEN を体験している（使い慣れている）方に向けた情報リンク集も掲載します。</p>
<h2 id="目次"><a class="header" href="#目次">目次</a></h2>
<ul>
<li><a href="./index.html">チュートリアル概要</a>
<ul>
<li><a href="./chapter_1-1.html">CHIRIMEN について</a>
<ul>
<li><a href="./chapter_1-1-1.html">CHIRIMEN コミュニティ</a></li>
</ul>
</li>
<li><a href="./chapter_1-2.html">Raspberry Pi について</a></li>
<li><a href="./chapter_1-3.html">JavaScript の基礎</a></li>
<li><a href="./chapter_1-4.html">良く使う情報へのリンク</a></li>
</ul>
</li>
<li><a href="./chapter_2.html">機材準備と Wi-Fi への接続</a>
<ul>
<li><a href="./chapter_2-1.html">ステップ0（機材準備）</a></li>
<li><a href="./chapter_2-2.html">ステップ1（ターミナル接続）</a>
<ul>
<li><a href="./chapter_2-2-1.html">Note. CLI操作について</a></li>
<li><a href="./chapter_2-2-2.html">Note. pi4 の利用方法</a></li>
</ul>
</li>
<li><a href="./chapter_2-3.html">ステップ2（Wi-Fi設定）</a></li>
</ul>
</li>
<li><a href="./chapter_3.html">Hello Real World（Lチカを実行する）</a>
<ul>
<li><a href="./chapter_3-1.html">配線</a></li>
<li><a href="./chapter_3-2.html">プログラムを書く</a></li>
<li><a href="./chapter_3-3.html">実行する</a></li>
<li><a href="./chapter_3-4.html">コードを読む</a></li>
</ul>
</li>
<li><a href="./chapter_4.html">GPIOを試す</a>
<ul>
<li><a href="./chapter_4-1.html">GPIOを理解する</a></li>
<li><a href="./chapter_4-2.html">GPIOを出力</a></li>
<li><a href="./chapter_4-3.html">GPIOを入力（onchange）</a>
<ul>
<li><a href="./chapter_4-3-1.html">onchange コードを読む</a></li>
</ul>
</li>
<li><a href="./chapter_4-4.html">GPIOを入力（ポーリング）</a>
<ul>
<li><a href="./chapter_4-4-1.html">ポーリングコードを読む</a></li>
</ul>
</li>
<li><a href="./chapter_4-5.html">GPIOセンサーを複数同時に使う</a>
<ul>
<li><a href="./chapter_4-5-1.html">Lチカのコードを書き換える</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="./chapter_5.html">I2Cデバイスを試す</a>
<ul>
<li><a href="./chapter_5-1.html">I2Cを理解する</a></li>
<li><a href="./chapter_5-2.html">SHT30編</a>
<ul>
<li><a href="./chapter_5-2-1.html">I2Cセンサー(SHT30)の認識を確認する</a></li>
<li><a href="./chapter_5-2-2.html">SHT30 のコード取得と実行</a></li>
<li><a href="./chapter_5-2-3.html">SHT30 のコードを読む</a></li>
<li><a href="./chapter_5-2-4.html">SHT30 のコードの詳細解説</a></li>
</ul>
</li>
<li><a href="./chapter_5-3.html">ADT7410編</a></li>
<li><a href="./chapter_5-4.html">GPIO と I2Cセンサーを組み合わせる</a></li>
</ul>
</li>
<li><a href="./chapter_6.html">IoTを試す</a>
<ul>
<li><a href="./chapter_6-1.html">遠隔LEDコントロール</a></li>
<li><a href="./chapter_6-2.html">PiZero サンプルコードの実行</a></li>
<li><a href="./chapter_6-3.html">PC サンプルコードの実行</a></li>
<li><a href="./chapter_6-4.html">自分専用チャンネルで制御</a></li>
<li><a href="./chapter_6-5.html">PiZero 側のコードを読む</a></li>
<li><a href="./chapter_6-6.html">PC 側のコードを読む</a></li>
</ul>
</li>
<li><a href="./chapter_7.html">常駐プログラム化する</a></li>
<li><a href="./chapter_8.html">他のいろいろなデバイスを試してみる</a>
<ul>
<li><a href="./chapter_8-1.html">応用センサーキットの使い方</a>
<ul>
<li><a href="./chapter_8-1-1.html">単体で動作確認できるセンサー</a></li>
<li><a href="./chapter_8-1-2.html">人感センサー</a></li>
<li><a href="./chapter_8-1-3.html">Neopixel LED</a></li>
<li><a href="./chapter_8-1-4.html">アナログセンサー</a></li>
<li><a href="./chapter_8-1-5.html">サーボモーター</a></li>
<li><a href="./chapter_8-1-6.html">DCモーター（MX1508利用）</a></li>
<li><a href="./chapter_8-1-7.html">DCモーター（PWM駆動）</a></li>
<li><a href="./chapter_8-1-8.html">RaspberryPi のカメラの注意点</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="./chapter_9.html">付録(予備知識)</a>
<ul>
<li><a href="./chapter_9-1.html">CHIRIMEN ブラウザー版との差異</a></li>
<li><a href="./chapter_9-2.html">CHIRIMEN環境の任意のディレクトリへのセットアップ</a></li>
</ul>
</li>
<li><a href="./chapter_10.html">共通資料集</a>
<ul>
<li><a href="./chapter_10-1.html">CHIRIMEN</a></li>
<li><a href="./chapter_10-2.html">ハードウェア・デバイス</a>
<ul>
<li><a href="./chapter_10-2-1.html">LED</a></li>
<li><a href="./chapter_10-2-2.html">ブレッドボード</a></li>
<li><a href="./chapter_10-2-3.html">抵抗値の読み方</a></li>
<li><a href="./chapter_10-2-4.html">MOSFETによる大電力制御</a></li>
</ul>
</li>
<li><a href="./chapter_10-3.html">JavaScript</a>
<ul>
<li><a href="./chapter_10-3-1.html">JavaScriptコード・ライブラリの読み込み</a></li>
<li><a href="./chapter_10-3-2.html">非同期処理</a></li>
</ul>
</li>
<li><a href="./chapter_10-4.html">GPIO</a>
<ul>
<li><a href="./chapter_10-4-1.html">GPIOポートの初期化と出力処理</a></li>
<li><a href="./chapter_10-4-2.html">GPIOPortの入力処理（onchange）</a></li>
<li><a href="./chapter_10-4-3.html">GPIOPortの入力処理（ポーリング）</a></li>
</ul>
</li>
<li><a href="./chapter_10-5.html">I2C</a>
<ul>
<li><a href="./chapter_10-5-1.html">各種ボードの I2C端子について</a></li>
<li><a href="./chapter_10-5-2.html">I2Cの詳細情報とポイント</a></li>
<li><a href="./chapter_10-5-3.html">WebI2C とデバイスドライバ</a></li>
</ul>
</li>
<li><a href="./chapter_10-6.html">IoT</a>
<ul>
<li><a href="./chapter_10-6-1.html">webSocketとpub/sub services</a></li>
<li><a href="./chapter_10-6-2.html">relayService</a></li>
<li><a href="./chapter_10-6-3.html">リアルタイム性</a></li>
<li><a href="./chapter_10-6-4.html">relayServer.js</a></li>
<li><a href="./chapter_10-6-5.html">プログラムの流れ</a></li>
<li><a href="./chapter_10-6-6.html">セキュリティ</a></li>
<li><a href="./chapter_10-6-7.html">Node.jsでの利用</a></li>
<li><a href="./chapter_10-6-8.html">Webhooks</a></li>
<li><a href="./chapter_10-6-9.html">IoTクラウドサービス</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11-chirimen-について"><a class="header" href="#11-chirimen-について">1.1 CHIRIMEN について</a></h1>
<p><img src="./imgs/CHIRIMEN_pf.png" alt="CHIRIMEN image" /></p>
<p>CHIRIMEN とは、Webの標準的な技術・ブラウザやNode.js等で実行できるJavaScript で電子パーツを制御し、<a href="https://www.iizuka.kyutech.ac.jp/faculty/physicalcomputing" target="_blank" rel="noopener noreferrer">フィジカルコンピューティング</a>や <a href="https://tutorial.chirimen.org/chirimenGeneric/#iot" target="_blank" rel="noopener noreferrer">IoTシステム</a>を開発可能なプロトタイピング環境です。</p>
<p>デジタルのソフトとフィジカルなハードをWWW上で連携するデバイスを Web標準技術、JavaScript だけで容易に実現できます。</p>
<ul>
<li><a href="https://tutorial.chirimen.org/about.html">さらに詳細に知りたい方はこちらを参照ください</a></li>
</ul>
<h2 id="chirimen-raspberry-pi-zero版について"><a class="header" href="#chirimen-raspberry-pi-zero版について">CHIRIMEN Raspberry Pi Zero版について</a></h2>
<ul>
<li>PiZero上ではWeb Browserを動かさない。</li>
<li>Node.jsというJavaScriptインタープリターだけが動く
<ul>
<li>ブラウザの機能のうち一部だけがPiZero上で使える
<ul>
<li>プログラミング言語 ～ JavaScript</li>
<li>画面表示やGUIに関わらないAPI</li>
<li>通信プロトコル</li>
</ul>
</li>
<li>使えないのはブラウザを使った画面表示やGUI</li>
</ul>
</li>
<li>ブラウザを使った画面やGUIは
<ul>
<li>ネットを介してスマホやPCからコントロール ⇒ これが代表的にIoTと呼ばれるデザインパターン
<ul>
<li>このとき、Raspberry Pi Zeroは、IoTエッジデバイスとして動作</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="111-chirimen-コミュニティ"><a class="header" href="#111-chirimen-コミュニティ">1.1.1 CHIRIMEN コミュニティ</a></h1>
<ul>
<li>CHIRIMEN についてもっと詳しく知りたい！</li>
<li>自分も開発に参加してみたい！</li>
</ul>
<p>などなど、興味を持たれた方は CHIRIMEN コミュニティへ是非参加してください。開発のできるエンジニアでなくとも、使っていて気になる点のフィードバックだけでも参加歓迎します。</p>
<p>ご希望の方は、こちらの Slack に参加をお願いします。</p>
<ul>
<li><a href="https://chirimen-oh.slack.com/">コミュニティ Slack</a></li>
</ul>
<p>初めてコミュニティに参加希望の方はこちらのフォームから登録してください。</p>
<ul>
<li><a href="https://docs.google.com/forms/d/1GzkGfCcsRn4A6-uHPsLu2LszkqKcNJ3sFI4XRishHsE/viewform">コミュニティ Slack 自己登録フォーム</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="12-raspberry-pi-について"><a class="header" href="#12-raspberry-pi-について">1.2 Raspberry Pi について</a></h1>
<p><img src="./imgs/raspi.jpg" alt="ラズパイ画像" /></p>
<ul>
<li>教育・学習用として設計されたシングルボードコンピュータ
<ul>
<li><a href="https://elchika.com/dic/%E3%82%B7%E3%83%B3%E3%82%B0%E3%83%AB%E3%83%9C%E3%83%BC%E3%83%89%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF/">シングルボードコンピュータ～PC・スマホとの違い</a></li>
</ul>
</li>
<li>Linuxが動作するシングルボードコンピュータとして、安価でとても高いシェアを持ち世界中で容易に入手できる</li>
<li>今回使用する Raspberry Pi Zero WH は、その中でも特に安価 (<a href="https://www.switch-science.com/catalog/3646/">3,000円程度</a>)で小型・低消費電力の機種、HDMI 出力はあるもののブラウザを動かすだけの処理能力がありませんが、IoT のエッジデバイス（センサーやアクチュエータが載ったデバイスでディスプレイはあるとしても簡易のもの）には適しています。
<ul>
<li>フルセットのブラウザが内蔵されたデバイスを作りたい場合は<a href="../raspi/">CHIRIMEN Raspberry Pi版</a>が使用できます。</li>
<li>インターネットを経由してPCやスマホのブラウザから遠隔操作するシステムは　この Pi Zero W 版でつくれます。<a href="chapter_1-2.html#iot">IoTの章</a>まで進めましょう。</li>
</ul>
</li>
<li>同じサイズの上位機種として、<a href="https://www.switch-science.com/products/7600">Raspberry Pi Zero 2 W</a> も発売されました。こちらも CHIRIMEN は対応しており、より性能を必要とする開発も可能になりました。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="13-javascript-の基礎"><a class="header" href="#13-javascript-の基礎">1.3 JavaScript の基礎</a></h1>
<p>標準化されたプログラミング言語の一種で、ウェブブラウザが代表的な実行環境です(プログラムコードを解釈して動作させるシステム)。CHIRIMEN では JavaScript で各種開発を行います。より詳細な情報は <a href="./chapter_10-3.html">10.3 JavaScript</a> を参照してください。</br></p>
<p>以下に初めて学ぶ方やより詳しい情報を知りたい方に向けたテキストが公開されています。</p>
<h2 id="web開発をはじめよう"><a class="header" href="#web開発をはじめよう"><a href="https://kou029w.github.io/intro-to-web-dev/index.html">Web開発をはじめよう</a></a></h2>
<p>Web開発を始める方に向けた入門ガイドです。JavaScript の他に HTML/CSS を用いる Web開発の基礎から GAS（Google Apps Script）を利用したアプリ開発まで解説されています。</p>
<h2 id="javascript-1-day-講習"><a class="header" href="#javascript-1-day-講習">JavaScript 1 Day 講習</a></h2>
<p>初めてプログラミングする人に 1 日で JavaScript を教えるときにちょうど良いボリューム・内容の資料です。</p>
<ul>
<li><a href="https://tutorial.chirimen.org/js/1dayJavaScript.pdf">PDF 版</a></li>
<li><a href="https://tutorial.chirimen.org/js/1dayJavaScript.key">Keynote 版 (オリジナル)</a></li>
<li><a href="https://tutorial.chirimen.org/js/1dayJavaScript.pptx">パワーポイント版</a></li>
</ul>
<h2 id="javascript-primer---ecmascript-2019時代のjavascript入門書"><a class="header" href="#javascript-primer---ecmascript-2019時代のjavascript入門書"><a href="https://jsprimer.net/">JavaScript Primer - ECMAScript 2019時代のJavaScript入門書</a></a></h2>
<p>最新言語仕様も考慮した本格的な JavaScript 入門書です。開発ツールなどについても <a href="https://jsprimer.net/appendix/links/">付録: 参考リンク集</a> が参考になります</p>
<h2 id="javascript-チートシート"><a class="header" href="#javascript-チートシート"><a href="https://jsprimer.net/cheetsheet/">JavaScript チートシート</a></a></h2>
<p>JavaScript の基本的な言語機能をまとめたチートシートです。プログラミング初心者はこちらを参照しながらコードを読み書きされることをオススメします。</p>
<h2 id="非同期処理-async-await-解説"><a class="header" href="#非同期処理-async-await-解説"><a href="https://tutorial.chirimen.org/js/async.html">非同期処理 (async await) 解説</a></a></h2>
<p>ハード制御で必ず必要だが引っかかる人が多い非同期処理について簡単な解説です。非同期処理についてより詳しくは <a href="https://jsprimer.net/basic/async/">JS Primer の非同期処理説明ページ</a> をご覧ください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="14-良く使う情報へのリンク"><a class="header" href="#14-良く使う情報へのリンク">1.4 良く使う情報へのリンク</a></h1>
<p>CHIRIMEN PiZero 版で良く使われるリンクをまとめたページです。</p>
<h2 id="chirimen-に関するリンク集"><a class="header" href="#chirimen-に関するリンク集">CHIRIMEN に関するリンク集</a></h2>
<ul>
<li><a href="https://chirimen.org/PiZeroWebSerialConsole/PiZeroWebSerialConsole.html">Web Serial RPiZero Terminal</a></li>
<li><a href="https://tutorial.chirimen.org/pizero/esm-examples/">CHIRIMEN with Node.js / RPi Zero Examples</a>
<ul>
<li>CHIRIMEN パネル の examples に PC からアクセスできます。</li>
</ul>
</li>
<li><a href="https://tutorial.chirimen.org/partslist">CHIRIMEN 対応デバイスリスト</a>
<ul>
<li>PiZero版に限らず、全ての CHIRIMEN に対応したデバイスリストです。</li>
</ul>
</li>
</ul>
<h2 id="開発に有用な情報サイト集"><a class="header" href="#開発に有用な情報サイト集">開発に有用な情報サイト集</a></h2>
<ul>
<li><a href="https://kou029w.github.io/intro-to-web-dev/index.html">Web開発をはじめよう</a>
<ul>
<li>Web開発を始める方に向けた入門ガイドです。</li>
</ul>
</li>
<li><a href="https://jsprimer.net/">JavaScript Primer - ECMAScript 2019時代のJavaScript入門書</a>
<ul>
<li>最新言語仕様も考慮した本格的な JavaScript 入門書です。</li>
</ul>
</li>
<li><a href="https://jsprimer.net/cheetsheet/">JavaScript チートシート</a>
<ul>
<li>JavaScript の基本的な言語機能をまとめたチートシートです。</li>
</ul>
</li>
<li><a href="https://github.com/webiotmakers/github-handson/blob/master/Docs/WIMC_GItHub_HandsOn.pdf">GitHub ハンズオン(PDF)</a>
<ul>
<li>GitHub の基本的な使い方の分かるハンズオン資料です。</li>
</ul>
</li>
<li><a href="https://csb-jp.github.io/">CodeSandbox ガイド</a>
<ul>
<li>ブラウザ上で開発する CodeSandbox の使い方を確認しましょう。</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-準備"><a class="header" href="#2-準備">2. 準備</a></h1>
<p>CHIRIMEN PiZero チュートリアルを実施するために必要な機材の準備や、環境設定を解説します。各ステップに従って準備を進めてください。</p>
<!--
必要な電子パーツ類の部材を一式揃えた、CHIRIMENスターターキットの頒布がされている場合、それを利用すると便利です。
--><div style="break-before: page; page-break-before: always;"></div><h1 id="21-ステップ０-物品準備pcをwifiに接続"><a class="header" href="#21-ステップ０-物品準備pcをwifiに接続">2.1 ステップ０ (物品準備、PCをWiFiに接続)</a></h1>
<h2 id="必要な物品リスト"><a class="header" href="#必要な物品リスト">必要な物品リスト</a></h2>
<p>以下を用意します</p>
<p><img src="imgs/PartsList2.svg" alt="Parts Images" /></p>
<ul>
<li><strong>Raspberry Pi Zero W</strong> (または Pi Zero <strong>2</strong> W)
<ul>
<li>Pi Zero: <a href="https://raspberry-pi.ksyic.com/main/index/pdp.id/406/pdp.open/406">ケイエスワイ</a>, <a href="https://akizukidenshi.com/catalog/g/gM-12961/">秋月電子</a>, <a href="https://www.switch-science.com/catalog/3646/">スイッチサイエンス</a>, <a href="https://www.marutsu.co.jp/pc/i/1320453/">マルツ</a></li>
<li>Pi Zero <strong>2</strong> W: <a href="https://raspberry-pi.ksyic.com/main/index/pdp.id/849/pdp.open/849">ケイエスワイ</a>, <a href="https://akizukidenshi.com/catalog/g/g117398/">秋月電子</a>, <a href="https://www.switch-science.com/collections/raspberry-pi/products/7600">スイッチサイエンス</a>, <a href="https://www.marutsu.co.jp/pc/i/2792770/">マルツ</a></li>
</ul>
</li>
<li><strong>microSDカード</strong>
<ul>
<li><a href="https://github.com/chirimen-oh/chirimen-lite/releases/latest">CHIRIMEN Lite 最新リリース版</a>を書き込みます</li>
<li>自分でイメージを書き込む場合は「<a href="https://tutorial.chirimen.org/raspi/sdcard">SDカードの作成の手順</a>」をご参考ください。</li>
</ul>
</li>
<li><strong>USBケーブル (USB A - MicroB)</strong></li>
<li><strong>Lチカ用パーツ</strong>(以下のパーツ一式を用意します)
<ul>
<li>ブレッドボード</li>
<li>LED</li>
<li>1KΩ抵抗</li>
<li>ジャンパーワイヤ オス-メス 2本</li>
</ul>
</li>
<li><strong>GPIO入力実験用追加パーツ</strong>(以下のパーツを用意します)
<ul>
<li>タクトスイッチ</li>
</ul>
</li>
<li><strong>モーター制御用追加パーツ</strong>(以下のパーツ一式を用意します)
<ul>
<li>10KΩ抵抗</li>
<li>MOSFET</li>
<li>ギヤードモーター（ミニモーター）</li>
</ul>
</li>
<li><strong>温度センシング実験用追加パーツ</strong>（温湿度センサーはいずれかを用意します）
<ul>
<li><a href="https://akizukidenshi.com/catalog/g/gM-06675/"><strong>ADT7410モジュール</strong></a>　もしくは <a href="https://www.amazon.co.jp/dp/B083NHJSL9/"><strong>SHT30モジュール</strong></a></li>
<li>ジャンパーワイヤ オス-メス 4本（追加 2本）</li>
</ul>
</li>
<li><strong>ブラウザの載ったパソコン</strong>（いずれもUSBとWiFiが使える必要があります）
<ul>
<li>Windows 10 PC
<ul>
<li>ブラウザは標準の Edge もしくは Chrome を使います。</li>
</ul>
</li>
<li>Macintosh
<ul>
<li>ブラウザは Chrome が必要です。</li>
</ul>
</li>
<li>Chrome OS / Chromebook
<ul>
<li>確認済みハード：Lenovo Chromebook S330</li>
</ul>
</li>
<li><em>Note: Linux PC の Chrome では次の設定で利用可能になるとの報告をいただいています</em>
<ul>
<li>Ubuntu Studio: <code>sudo chmod a+rw /dev/ttyACM0</code></li>
<li>Ubuntu Desktop 20.04 LTS: <code>sudo gpasswd -a "$(whoami)" dialout</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>※ PiZero自体はディスプレイやキーボードを接続する必要はありません。</p>
<h2 id="開発用-pc-をネットワークに接続"><a class="header" href="#開発用-pc-をネットワークに接続">開発用 PC をネットワークに接続</a></h2>
<ul>
<li>会場(もしくは開発場所)で提供されているネットワークにまずはPCを接続してください。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="22-ステップ1ターミナル接続"><a class="header" href="#22-ステップ1ターミナル接続">2.2 ステップ1（<a href="https://chirimen.org/PiZeroWebSerialConsole/PiZeroWebSerialConsole.html">ターミナル接続</a>）</a></h1>
<ol>
<li><a href="https://github.com/kou029w/chirimen-os/releases/">CHIRIMEN Lite 最新リリース版</a>を書き込んだ microSDカードを Raspberry Pi Zero に差し込みます。</li>
<li>PCの USB と Raspberry Pi Zero の USB OTGポートを USBケーブルでつなぎます
<ul>
<li>PiZero側はつなぐポート要注意　下図の矢印の所に繋ぎます
<img src="./imgs/PiZeroW_OTG.jpg" alt="pi zero otg port" /></li>
<li>PC からの USB給電で Raspberry Pi Zero が起動します。</li>
</ul>
</li>
<li>PCでRaspberry Pi Zeroが認識されたことを確認します (<a href="https://askpc.panasonic.co.jp/beginner/guide/ten07/7013.html">Windows10のデバイスマネージャ</a>の例)
<ul>
<li>給電後USBデバイスとして出現するまでにしばらく(数十秒)かかります</li>
<li>Windowsの場合、ポートの番号(COMnのnの部分)は環境ごとに異なります
<img src="imgs/OTG_PORT_W10.png" alt="OTG PORT Information on device manager" /></li>
<li><a href="https://chirimen.org/PiZeroWebSerialConsole/PiZeroWebSerialConsole.html"><strong>こちらのWeb Serial RPiZero TerminalページにPCのブラウザでアクセス</strong></a>
(以降、このウィンドを<strong>ターミナルウィンド</strong>と呼びます)</li>
</ul>
</li>
<li>ターミナルウィンドの <code>[Connect and Login PiZero]</code> ボタンを押す
<ul>
<li>接続ダイアログが出現
<img src="imgs/SerialDialog.png" alt="connection dialog" /></li>
<li>上で認識したデバイス（ポート番号）を接続する</li>
</ul>
</li>
<li>コンソール(左側の黒い画面の最下部)に以下のコマンドプロンプトが表示されればステップ１完了です。引き続きステップ２に進んでください
<ul>
<li><code>pi@raspberrypi:~$</code></li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notechirimen-lite-の-cli-操作について"><a class="header" href="#notechirimen-lite-の-cli-操作について">Note:CHIRIMEN-lite の CLI 操作について</a></h1>
<ul>
<li>CHIRIMEN Raspberry Pi Zero 版では <a href="https://www.raspberrypi.com/software/operating-systems/">Raspberry Pi OS Lite</a> (Linux) をコマンドラインインターフェース (CLI)・シェル (bash) で操作します。
<ul>
<li>ただしこの講習ではターミナルウィンドによる GUI 操作が可能で、使うコマンドはごくわずかです。
<ul>
<li><strong>node</strong> コマンド(後述)</li>
<li><a href="https://atmarkit.itmedia.co.jp/ait/articles/1708/04/news015_2.html">CTRL+c</a>（CTRLキーとcを同時に押す:実行中のコマンドを終了させる）</li>
</ul>
</li>
<li>その他のほとんどの操作（コマンド）は、ターミナルウィンドやそこから起動される別画面のGUIがコマンド操作を代行しています。図1.1 の GUI を操作するとコンソールにコマンドが入力されるのがわかると思います。</li>
</ul>
</li>
<li>ターミナルウィンドの概要 (図1.1)
<img src="imgs/termWin.svg" alt="ターミナルウィンドの説明" /></li>
<li><a href="https://atmarkit.itmedia.co.jp/ait/articles/1602/19/news025.html">CLIとは</a></li>
<li><a href="https://atmarkit.itmedia.co.jp/ait/articles/1603/02/news016.html">シェルとコマンドプロンプト</a></li>
<li>もしもあなたがlinuxのシェルコンソール画面に慣れている場合は、ターミナルウィンドのコンソールにその他のシェル(bash)コマンドをタイプして使用することもできます。
<ul>
<li>たとえば <code>ls -al</code> とタイプするとおコンソール画面にディレクトリ内のファイルのリストが表示されます。</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="note-raspberry-pi4-の利用方法"><a class="header" href="#note-raspberry-pi4-の利用方法">Note. Raspberry Pi4 の利用方法</a></h1>
<ul>
<li>このチュートリアルは PiZero 以外にも Raspberry Pi4 も使用可能です。</li>
<li>Pi4 の USB 給電口と PC を接続して同様にチュートリアルが可能です。
<ul>
<li>PiZero より Pi4 は消費電力が多いため電力不足になると同様の動作が出来ない場合があります。</li>
<li>使用する USBケーブルは Type-C になります。</li>
</ul>
</li>
</ul>
<p><img src="./imgs/pi4usbotg.jpg" alt="Pi4 usb-otg" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="23-ステップ2-wifi設定"><a class="header" href="#23-ステップ2-wifi設定">2.3 ステップ2 (WiFi設定)</a></h1>
<ol>
<li>ターミナルウィンドの<code>[wifi panel]</code>ボタンを押す
<ul>
<li>ウィンドが開き、WiFiアクセスポイントがスキャンされます。ステルスでないものはリストアップされているので、以降の作業の参考にしてください。</li>
<li>Raspberry Pi Zero W は <strong>2.4GHz帯の WiFi</strong> にのみ対応しています。
<img src="./imgs/WiFiSetting.png" alt="WiFi Setting" /></li>
</ul>
</li>
<li>ウィンド下部に、WiFiアクセス情報を入力する (いずれも大文字小文字の区別があるので注意してください)
<ul>
<li>SSID欄</li>
<li>PASS PHRASE欄</li>
</ul>
</li>
<li><code>[SET WiFi]</code>ボタンを押す</li>
<li><code>[Reboot]</code>ボタンを押す
<ul>
<li>これで Raspberry Pi Zero が再起動をはじめます</li>
</ul>
</li>
<li>WiFiウィンドを閉じ、ターミナルウィンドに戻る</li>
<li>ターミナルウィンドの<code>[Close Connection]</code>ボタンを押す</li>
<li>1-2分程待つ（Raspberry Pi Zeroが再起動します）</li>
<li><code>[Connect and Login PiZero]</code>ボタンを押し接続する
<ul>
<li>接続ダイアログが出現⇒接続するとこれまで同様コマンドプロンプトが出現</li>
</ul>
</li>
<li><code>[wifi panel]</code>ボタンを再び押す</li>
<li><code>[wifi Info]</code>ボタンを押す
<ul>
<li>表示された情報をチェックします</li>
<li>wlan0: inet xxx.xxx.xxx.xxx　(xxxは数字)のようにIPアドレスが設定されていれば接続成功しています。
<img src="./imgs/WiFiSettingIPaddress.png" alt="WiFi Setting_IPaddress" /></li>
</ul>
</li>
<li>確認できたらWiFi Settingウィンドを閉じてください。</li>
</ol>
  <!--  * あとでping chirimen.org OK も入れよう。-->
<ul>
<li>もしもあなたがsshやscp (WinSCP, teraterm等)などのツールに慣れている場合、上記のアドレスでssh接続できます
<ul>
<li>PORT: 22</li>
<li>ID: <code>pi</code></li>
<li>PASSWORD: <code>raspberry</code></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-hello-real-worldlチカを実行する"><a class="header" href="#3-hello-real-worldlチカを実行する">3. Hello Real World（Lチカを実行する）</a></h1>
<p><img src="./imgs/l-chika.jpg" alt="Lチカ写真" />
「L チカ」とは、LED を点けたり消したりチカチカ点滅させることです。</br>「LED を点ける」「LED を消す」をプログラムで繰り返し実行することで実現します。</br>この章では CHIRIMEN での開発方法を学びつつ、Lチカを実現させる方法を解説していきます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="31-配線"><a class="header" href="#31-配線">3.1 配線</a></h1>
<p>PiZero とパーツを使って下の図の通りに配線します。</p>
<p><img src="./imgs/pizero_led.png" alt="PiZero配線図" /></p>
<p><strong>！！注意！！</strong></p>
<ul>
<li>間違ったピンに差し込むと場合によってはPiZeroが停止したり故障することもあります。（たとえば3.3V端子とGND端子を接続してしまうなど。）</li>
<li>そのため、慣れるまでは一旦PiZeroをシャットダウン、USBケーブルも外し電源OFFにしてから配線すると安全です
<ul>
<li>シャットダウンコマンド：<code>sudo shutdown -h now</code>
<img src="./imgs/led.jpg" alt="LEDイラスト" /></li>
</ul>
</li>
<li><a href="https://tutorial.chirimen.org/raspi/hellorealworld#section-1">LEDの極性に注意！</a>
<ul>
<li>LED には極性 (方向) があり、足が長い方 (アノード) を GPIO 出力ピンに、足が短い方 (カソード) を GND 側に繋いでください。</li>
<li><a href="./chapter_10-2-1.html">LEDの説明</a></li>
</ul>
</li>
<li><a href="./chapter_10-2-2.html">ブレッドボードの使い方</a></li>
<li><a href="./chapter_10-2-3.html">抵抗値の読み方</a></li>
<li><a href="https://tutorial.chirimen.org/reference#section-1">その他、配線の基礎知識</a></li>
<li>配線に使うケーブルの色に厳密な決まりはありませんが、一般的にGNDは黒(や黒っぽい色)、電源(VCC, +3.3V, +5V)には赤(や赤っぽい色)が用いられます。配線間違いを防ぐためにもなるべく合わせましょう。</li>
<li>抵抗や LED の足(リード線)は手で簡単に曲げられます。ブレッドボードに差し込めるように適当に成型してください。</li>
<li>上図の PiZero は上から見たものです</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="32-プログラムを書く"><a class="header" href="#32-プログラムを書く">3.2 プログラムを書く</a></h1>
<p>Raspberry Pi に接続した LED を点滅させるプログラムを書きます。</p>
<ol>
<li>ターミナルウィンドで Raspberry Pi Zero に接続します。（準備のステップ１まで完了した状態）</li>
<li>myAppディレクトリに移動します。
<ul>
<li>コンソールの右側のファイルマネージャでmyApp⇒移動を選ぶ</li>
<li>このディレクトリが開発環境が設定されているディレクトリです。</li>
</ul>
</li>
<li><code>[Create New Text]</code>ボタンを押す</li>
<li>入力欄に<code>hello.js</code>と入力</li>
<li><code>[create]</code>ボタンを押す</li>
<li>JS Editorウィンドが出現</li>
</ol>
<p>以下のプログラムをJS Editorに書き写します ～ コピペ（下記プログラム部分を選択してCTRL+c、JS Editorウィンド上でCTRL+v））</p>
<h3 id="lチカのプログラムソースコード"><a class="header" href="#lチカのプログラムソースコード">Lチカのプログラムソースコード</a></h3>
<pre><code class="language-js">import {requestGPIOAccess} from "./node_modules/node-web-gpio/dist/index.js"; // WebGPIO を使えるようにするためのライブラリをインポート
const sleep = msec =&gt; new Promise(resolve =&gt; setTimeout(resolve, msec)); // sleep 関数を定義

async function blink() {
  const gpioAccess = await requestGPIOAccess(); // GPIO を操作する
  const port = gpioAccess.ports.get(26); // 26 番ポートを操作する

  await port.export("out"); // ポートを出力モードに設定

  // 無限ループ
  for (;;) {
    // 1秒間隔で LED が点滅します
    await port.write(1); // LEDを点灯
    await sleep(1000);   // 1000 ms (1秒) 待機
    await port.write(0); // LEDを消灯
    await sleep(1000);   // 1000 ms (1秒) 待機
  }
}

blink();
</code></pre>
<ol start="7">
<li>書き終えたら保存します。(<code>[Save]ボタン</code>もしくは <code>CTRL+s</code> )</li>
<li>ターミナルウィンドの右側 (ファイルマネージャ) に <strong>hello.js</strong> が出現していることを確認します</li>
<li>エディタウィンドを閉じます</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="33-実行する"><a class="header" href="#33-実行する">3.3 実行する</a></h1>
<ol>
<li>ターミナルウィンドのコンソール部 (ウィンド左側) のプロンプト (画面一番下) が以下になっていることを確認します
<ul>
<li><code>pi@raspberrypi:~/myApp$</code></li>
</ul>
</li>
<li>コンソール部をクリックして、入力可能状態にしてから、以下の文字を入力します。</li>
<li><code>node hello.js</code> ENTERキー
<ul>
<li><strong>node</strong> はJavaScriptのコードを実行する<a href="https://ja.wikipedia.org/wiki/%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%97%E3%83%AA%E3%82%BF">インタープリタ</a></li>
<li><a href="https://atmarkit.itmedia.co.jp/ait/articles/1102/28/news105.html">nodeコマンドについて</a></li>
</ul>
</li>
<li>LED が点滅すれば完成です 🎉</li>
<li>プログラムを止めるには、コンソール部で <code>CTRL+c</code> を押します。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="34-コードを読む"><a class="header" href="#34-コードを読む">3.4 コードを読む</a></h1>
<ul>
<li>
<p>前提：CHIRIMEN Rasoberryu Pi Zero は Node.js をプログラム実行環境（インタープリタ）として使っています。</p>
</li>
<li>
<p>Raspberry Pi Zero 版はプログラムの起点が自分が作った JavaScriptコード自体になります。</p>
</li>
<li>
<p>ブラウザの代わりに<a href="https://ja.wikipedia.org/wiki/Node.js">Node.js</a>という JavaScriptコードだけを解釈するソフト（JavaScript <a href="https://ja.wikipedia.org/wiki/%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%97%E3%83%AA%E3%82%BF">インタープリタ</a>）にコードを読み込ませて実行します。</p>
</li>
<li>
<p>ターミナルウィンドの右側のファイルマネージャで<code>hello.js</code> ⇒ 表示 を選び、ソースコードを読んでみましょう</p>
</li>
</ul>
<pre><code class="language-js">import {requestGPIOAccess} from "./node_modules/node-web-gpio/dist/index.js"; // WebGPIO を使えるようにするためのライブラリをインポート
const sleep = msec =&gt; new Promise(resolve =&gt; setTimeout(resolve, msec)); // sleep 関数を定義

async function blink() {
  const gpioAccess = await requestGPIOAccess(); // GPIO を操作する
  const port = gpioAccess.ports.get(26); // 26 番ポートを操作する

  await port.export("out"); // ポートを出力モードに設定

  // 無限ループ
  for (;;) {
    // 1秒間隔で LED が点滅します
    await port.write(1); // LEDを点灯
    await sleep(1000);   // 1000 ms (1秒) 待機
    await port.write(0); // LEDを消灯
    await sleep(1000);   // 1000 ms (1秒) 待機
  }
}

blink();
</code></pre>
<ul>
<li>
<p><strong>1行目：WebGPIOライブラリを読み込み</strong> (<a href="./chapter_10-3-1.html">JavaScript Module</a>仕様に従って)</p>
<pre><code class="language-js">import {requestGPIOAccess} from "./node_modules/node-web-gpio/dist/index.js";
</code></pre>
<ul>
<li><a href="./chapter_10-3-1.html">JavaScript module</a> に基づいてWebGPIOライブラリを読み込みます。これで Web GPIO API が使えるようになりました。</li>
</ul>
</li>
<li>
<p><strong>5行目：GPIOポートの初期化処理</strong></p>
<pre><code class="language-js">const gpioAccess = await requestGPIOAccess();
</code></pre>
<ul>
<li>今回の JavaScript ファイルで、最初に呼び出されるコードは <code>await navigator.requestGPIOAccess()</code> です。</li>
<li>ここで先ほど出て来た <a href="http://browserobo.github.io/WebGPIO">Web GPIO API</a> を使い、<code>gpioAccess</code> という GPIO にアクセスするためのインタフェースを取得しています。</li>
</ul>
</li>
</ul>
<p><strong>関数の呼び出しに <code>await</code> 接頭詞を付けることに注意してください。</strong> この関数は非同期関数で、その処理の完了を待ってから次の処理をする必要があります。また、<code>await</code> 接頭詞を使うコードを含むために、それを含む関数 <code>main()</code> は async 接頭詞付きの非同期関数として定義する必要があります。</p>
<ul>
<li>
<p><strong>6-8行目：GPIOPortの出力処理</strong></p>
<pre><code class="language-js">const port = gpioAccess.ports.get(26);
</code></pre>
<ul>
<li>GPIOの<strong>出力</strong>機能を使います。</li>
<li><strong><code>const port = gpioAccess.ports.get(26)</code> で GPIO の 26 番ポートにアクセスするためのオブジェクト</strong> を取得しています。</li>
</ul>
<pre><code class="language-js">await port.export("out");
</code></pre>
<ul>
<li>続いて、 <strong><code>await port.export("out")</code> で GPIO の 26 番を「出力設定」にしています</strong>。これにより LED への電圧の切り替えが可能になっています。</li>
</ul>
</li>
<li>
<p><strong>11行目以降：無限ループ部分</strong></p>
<ul>
<li>最後に、無限ループのなかで <code>await sleep(1000)</code> によって 1000 ms (1 秒) 待機させます。</li>
<li>1 秒ごとに <code>await port.write(1)</code> と <code>await port.write(0)</code> を交互に呼び出し、GPIO 26 番に加える電圧を 3.3V → 0V → 3.3V → 0V → … と繰り返しています。</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-gpioを試す"><a class="header" href="#4-gpioを試す">4. GPIOを試す</a></h1>
<p>Lチカが無事に動いたら、あなたは IoT開発の第一歩を踏み始めました。次は LED を光らせる以外のセンサーやアクチュエーターを使用する為に GPIO についてより深く学んでいきます。</p>
<p>ここからは実際にミニモーターを動作させるサンプルと、ボタンの入力デモを行っていきます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="41-gpioを理解する"><a class="header" href="#41-gpioを理解する">4.1 GPIOを理解する</a></h1>
<p><a href="https://ja.wikipedia.org/wiki/GPIO">GPIO</a>は、「General-purpose input/output」の略で汎用的な入出力インタフェースのことです。</p>
<p>Raspi に実装されている 40 本のピンヘッダから GPIO を利用することができます。</p>
<p>CHIRIMEN Raspi、Raspi Zero では Raspi が提供する 40 本のピンヘッダのうち、下記緑色のピン(合計 17 本)が利用可能です。</p>
<ul>
<li>白い文字で書かれたピンだけが使えます</li>
<li>GND、3.3V、5Vはそれぞれ電源とグランドです</li>
<li>数字 + PD||PUと書かれているピンは GPIO端子
<ul>
<li>PD:プルダウン, PU:プルアップ</li>
</ul>
</li>
<li>SCL, SDAはI2Cインターフェースのピンです(詳細は <a href="./chapter_5.html">I2Cデバイスを試す</a>にて)</li>
</ul>
<p><img src="https://chirimen.org/PiZeroWebSerialConsole/wallpaperS.png" alt="Raspberry Pi Pinout" /></p>
<p>Raspi の GPIO 端子は、GND 端子との間に、0V もしくは 3.3V の電圧を印加(出力)したり、逆に 0V もしくは 3.3V の電圧を検知(入力)したりすることができます。LED は数 mA の電流を流すことによって点灯できる電子部品のため、印加する電圧を 3.3V(点灯)、0V(消灯) と変化させることで L チカが実現できるのです。</p>
<p>詳しくは<a href="https://tool-lab.com/make/raspberrypi-startup-22/">こちらのサイトの解説</a>などを参考にしてみましょう。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="42-gpioを出力"><a class="header" href="#42-gpioを出力">4.2 GPIOを出力</a></h1>
<p>GPIOの出力はLチカで実験済みですね。そこで今回はモーターを動かしてみましょう。MOSFETを使った回路図は以下のようになります。</p>
<p><img src="./imgs/PiZero_gpio0Motor.png" alt="GPIO Motor" /></p>
<p>コードは Lチカと全く同じ（hello.js）を使用して動作可能です。</p>
<ul>
<li><code>node hello.js</code> ENTERキー</li>
</ul>
<h3 id="回路について"><a class="header" href="#回路について">回路について</a></h3>
<ul>
<li><a href="./chapter_10-2-4.html">10.2.4 MOSFETを使った大電力制御</a>を参照してください</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="43-gpioを入力onchange"><a class="header" href="#43-gpioを入力onchange">4.3 GPIOを入力（onchange）</a></h1>
<p>GPIO端子の<strong>入力が変化したら関数を実行</strong>という機能によってGPIOの入力を使います。</p>
<ol>
<li>ターミナルウィンドの<code>[CHIRIMEN Panel]</code>ボタンを押す</li>
<li>出現したCHIRIMEN Panelの<code>[Get Examples]</code>ボタンを押す</li>
<li>ID : <a href="https://tutorial.chirimen.org/pizero/esm-examples/#GPIO_gpio-onchange"><strong>gpio-onchange</strong></a> を探します</li>
<li>回路図リンクを押すと回路図が出てきますので、回路を組みます。</li>
<li><code>[JS GET]</code>ボタンを押すと、開発ディレクトリ(<code>~/myApp</code>)に、サンプルコードが保存されます。
<ul>
<li><strong>main-gpio-onchange.js</strong>というファイル名で保存されます。</li>
<li>ターミナルウィンドの右側のファイルマネージャでmain-gpio-onchange.js⇒編集 を選びます。</li>
</ul>
</li>
<li>実行する
<ul>
<li>ターミナルウィンドのコンソールのプロンプトが<code>pi@raspberrypi:~/myApp$</code>となっていることを確認</li>
<li>ターミナルウィンドのコンソールに、<code>node main-gpio-onchange.js</code> [ENTER] と入力して実行。</li>
<li>タクトスイッチを押してみます。</li>
<li>タクトスイッチが押されるたびにコンソール画面に<strong>0</strong>(押された状態)、<strong>1</strong>(離した状態)が交互に表示されます。
<ul>
<li>Note: GPIOポート5は、Pull-Up(開放状態でHighレベル)です。そのため離した状態で１が出力されます。スイッチを押すとポートがGNDと接続され、Lowレベルになり、0が出力されます。</li>
</ul>
</li>
</ul>
</li>
<li>終了は CTRL+c</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="431-onchange-コードを読む"><a class="header" href="#431-onchange-コードを読む">4.3.1 onchange コードを読む</a></h1>
<p>ターミナルウィンドの右側のファイルマネージャでmain-gpio-onchange.js⇒表示 を選び、ソースコードを読んでみましょう</p>
<ul>
<li>GPIOポートの値が変化するたびに、指定した関数が実行されます。</li>
</ul>
<pre><code class="language-js">import {requestGPIOAccess} from "./node_modules/node-web-gpio/dist/index.js";
const sleep = msec =&gt; new Promise(resolve =&gt; setTimeout(resolve, msec));

async function switchCheck() {
  const gpioAccess = await requestGPIOAccess();
  const port = gpioAccess.ports.get(5);

  await port.export("in");
  port.onchange = showPort;

}

function showPort(ev){
	console.log(ev.value);
}

switchCheck();
</code></pre>
<p>GPIOポートの初期化は Lチカの <a href="./chapter_3-4.html">3.4 コードを読む</a>と同様の処理を行っています。今回のコードでは 5 番ポートにアクセスするためのオブジェクトを取得し、<strong>GPIO入力</strong>機能を使って 5番を「入力設定」にしています。</p>
<p><code>port.onchange</code> は <strong>入力モードの GPIO ポートの「状態変化時に呼び出される関数を設定する」</strong> 機能です。このような関数のことをコールバック関数と呼びます。<code>port.read()</code> を使ったコードと異なり<a href="./chapter_4-4.html">ポーリング処理</a>が不要でコードも簡潔ですが、値が変化したタイミング以外では読み取りができませんのでユースケースが少し限られます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="44-gpioを入力ポーリング"><a class="header" href="#44-gpioを入力ポーリング">4.4 GPIOを入力（ポーリング）</a></h1>
<p>入力ではイベントの他にポーリングというテクニックが広く使われます。（次章のI2Cデバイスからの入力では専らポーリング）</p>
<ol>
<li>
<p>ターミナルウィンドの<code>[CHIRIMEN Panel]</code>ボタンを押す</p>
</li>
<li>
<p>出現したCHIRIMEN Panelの<code>[Get Examples]</code>ボタンを押す</p>
</li>
<li>
<p>ID : <a href="https://tutorial.chirimen.org/pizero/esm-examples/#GPIO_gpio-polling"><strong>gpio-polling</strong></a> を探します</p>
</li>
<li>
<p>回路は前章と同じなのでそのままにしておきます。</p>
</li>
<li>
<p><code>[JS GET]</code>ボタンを押すと、開発ディレクトリ(<code>~/myApp</code>)に、サンプルコードが保存されます。</p>
<ul>
<li><strong>main-gpio-polling.js</strong>というファイル名で保存されます。</li>
<li>ターミナルウィンドの右側のファイルマネージャでmain-gpio-polling.js⇒編集 を選びソースコードを見てみましょう</li>
</ul>
</li>
<li>
<p>実行する</p>
<ul>
<li>プロンプトが<code>pi@raspberrypi:~/myApp$</code>となっていることを確認</li>
<li>コンソールに、<code>node main-gpio-polling.js</code> [ENTER] と入力して実行。</li>
<li>0.3秒おきにポート5の値がコンソールに表示されていきます。</li>
<li>タクトスイッチを押してみます。</li>
<li>タクトスイッチが押されると、<strong>0</strong>に変化します。</li>
</ul>
</li>
<li>
<p>終了は CTRL+c</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="441-polling-コードを読む"><a class="header" href="#441-polling-コードを読む">4.4.1 polling コードを読む</a></h1>
<p>様々な情報や値の取得や入力のための基本的な機能・関数は、入力を指定した瞬間、一回きり取得するだけのものがほとんどです。そこで、無限ループをつくりこの中で一回きりの入力を定期的に繰り返すことで、入力の変化を読み取る　ということがよく行われます。このような処理を一般にポーリングと呼びます。 (<a href="https://ja.wikipedia.org/wiki/%E3%83%9D%E3%83%BC%E3%83%AA%E3%83%B3%E3%82%B0_(%E6%83%85%E5%A0%B1)">wikipedia:ポーリング</a>)</p>
<p>ターミナルウィンドの右側のファイルマネージャでmain-gpio-polling.js⇒表示 を選び、ソースコードを読んでみましょう</p>
<pre><code class="language-js">import {requestGPIOAccess} from "./node_modules/node-web-gpio/dist/index.js";
const sleep = msec =&gt; new Promise(resolve =&gt; setTimeout(resolve, msec));

async function switchCheck() {
  const gpioAccess = await requestGPIOAccess();
  const port = gpioAccess.ports.get(5);

  await port.export("in");

  for(;;){
    const v = await port.read();
	console.log(v);
    await sleep(300);
  }

}

switchCheck();
</code></pre>
<p>GPIOポートの初期化は Lチカの <a href="./chapter_3-4.html">3.4 コードを読む</a>と同様の処理を行っています。</p>
<p><code>port.export("in")</code> により取得した <strong>GPIO ポートを「入力モード」で初期化</strong> しています。このモードは GPIO ポートにかかる電圧を Web アプリ側から読み取りたい時に使います。初期化は非同期処理であり <code>await</code> で完了を待つ必要があることに注意してください。
単純に「GPIO ポートの状態を読み込む」には <code>port.read()</code> を使います。</p>
<p>「スイッチが押された状態を監視する」必要がありますので、定期的に <code>await port.read()</code> を繰り返して GPIO ポートの状態を監視するポーリングのルーチンを無限ループで組んでいます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="45-gpioセンサーを複数同時に使う"><a class="header" href="#45-gpioセンサーを複数同時に使う">4.5 GPIOセンサーを複数同時に使う</a></h1>
<h2 id="ボタンで点灯する-led--回転するモーター制御"><a class="header" href="#ボタンで点灯する-led--回転するモーター制御">ボタンで点灯する LED ／ 回転するモーター制御</a></h2>
<ul>
<li>
<p>LED の点滅制御（Lチカ）から、ボタンで点灯する制御に変更してみましょう。</p>
</li>
<li>
<p>回路図は以下の通りに接続します。LED/モーターのどちらかで動作させることが出来ます。</p>
<ul>
<li>GPIO PORT5にスイッチ、GPIOPORT26に抵抗とLED を繋ぎます
<img src="./imgs/PiZero_gpio-inout.png" width=500></li>
</ul>
</li>
<li>
<p>モーターを使用した際の回路図は以下となります。</p>
<ul>
<li>GPIO PORT5にスイッチ、GPIOPORT26にモーター制御回路を繋ぎます
<img src="./imgs/PiZero_gpio-inoutMotor.png" width=800></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="451-lチカのコードを書き換える"><a class="header" href="#451-lチカのコードを書き換える">4.5.1 Lチカのコードを書き換える</a></h1>
<ul>
<li>Lチカのコードを書き換えて、スイッチで動作する様に変更します。</li>
<li>正しく回路を接続し、コードを書き換えたらボタンを押した時に LED やモーターが動作する様になります。
<ul>
<li>上手く動作しない方は、コピペで動作を確認してみましょう。</li>
</ul>
</li>
<li>複数の関数で変数を使用できるように port 変数を宣言しなおします。</li>
</ul>
<pre><code class="language-js">const sleep = msec =&gt; new Promise(resolve =&gt; setTimeout(resolve, msec));
let port; // port 変数を複数の関数で使えるように宣言

async function blink() {
  const gpioAccess = await requestGPIOAccess();
  port = gpioAccess.ports.get(26); // 26 番ポートを操作する、ここの変数は宣言済みなので const は削除する
</code></pre>
<ul>
<li>無限ループの処理は削除します。</li>
</ul>
<pre><code class="language-js">  /* ここは削除する
  // 無限ループ
  for (;;) {
    // 1秒間隔で LED が点滅します
    await port.write(1); // LEDを点灯
    await sleep(1000);   // 1000 ms (1秒) 待機
    await port.write(0); // LEDを消灯
    await sleep(1000);   // 1000 ms (1秒) 待機
  }
</code></pre>
<ul>
<li>ボタンの初期化処理を記述します。</li>
</ul>
<pre><code class="language-js">  const port2 = gpioAccess.ports.get(5);
  await port2.export("in");
  port2.onchange = showPort;
}
</code></pre>
<ul>
<li>ボタンの処理を追記します。</li>
</ul>
<pre><code class="language-js">function showPort(ev){
	console.log(ev.value);
    if (ev.value==0){
        port.write(1);
    } else {
        port.write(0);
    }
}
</code></pre>
<ul>
<li>全体のソースコードは以下のとおりとなります。</li>
</ul>
<pre><code class="language-js">import {requestGPIOAccess} from "./node_modules/node-web-gpio/dist/index.js"; // WebGPIO を使えるようにするためのライブラリをインポート
const sleep = msec =&gt; new Promise(resolve =&gt; setTimeout(resolve, msec)); // sleep 関数を定義
let port; // port 変数を複数の関数で使えるように宣言

async function blink() {
  const gpioAccess = await requestGPIOAccess(); // GPIO を操作する
  port = gpioAccess.ports.get(26); // 26 番ポートを操作する、ここの変数は宣言済みなので const 宣言は削除する

  await port.export("out"); // ポートを出力モードに設定

  // ここから記述する
  const port2 = gpioAccess.ports.get(5);
  await port2.export("in");
  port2.onchange = showPort;
}

function showPort(ev){
	console.log(ev.value);
    if (ev.value==0){
        port.write(1);
    } else {
        port.write(0);
    }
}
  // ここまで

blink();
</code></pre>
<p>このコードは CHIRIMEN パネルの ID: <strong>gpio-inout</strong> と同じコードになりますので上手く動作しなかった方は、こちらも併用して確認してみてください</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="5-i2cデバイスを試す"><a class="header" href="#5-i2cデバイスを試す">5. I2Cデバイスを試す</a></h1>
<ul>
<li>I2C（アイ・ツー・シー／アイ・スクエアド・シー）センサの使い方を学びます。</li>
<li>I2Cセンサを利用するにあたり、以下のポイントが重要になります。</li>
</ul>
<h2 id="ポイント"><a class="header" href="#ポイント">ポイント</a></h2>
<p>I2C の概要として下記を押さえておきましょう。</p>
<ul>
<li>I2C バスを介して複数のデバイスが繋がる</li>
<li>I2C デバイスにはマスターとスレーブがある</li>
<li>I2C ではマスターからスレーブに対して通信要求が行われる</li>
<li>I2C スレーブは SlaveAddress を持つ</li>
<li>同じ I2C バスに同じ SlaveAddress のデバイスは繋げない</li>
</ul>
<h3 id="raspberry-pi-の-i2c端子"><a class="header" href="#raspberry-pi-の-i2c端子">Raspberry Pi の I2C端子</a></h3>
<p>下図のSCL, SDAがI2C端子です（黄色の端子）
<img src="https://chirimen.org/PiZeroWebSerialConsole/wallpaperS.png" alt="Raspi PIN配置図" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="51i2cを理解する"><a class="header" href="#51i2cを理解する">5.1I2Cを理解する</a></h1>
<h2 id="i2cの概要"><a class="header" href="#i2cの概要">I2Cの概要</a></h2>
<p><a href="https://ja.wikipedia.org/wiki/I2C">I2C</a> とは 2 線式の同期式シリアル通信インタフェースです。「アイ・スクエア・シー」や「アイ・ ツー・シー」と読みます。I2C では SDA（シリアルデータ）と SCL（シリアルクロック）の 2 本の線で通信を行います。</p>
<p><img src="./imgs/i2c-bus.png" alt="i2c-bus" /></p>
<p>上図のように、I2C の SDA、SCL は複数のデバイス間で共有され、これを「I2C バス」と言います。I2C ではマスターとスレーブの間で通信が行われます。常にマスター側からスレーブ側に要求が行われ、スレーブ側からマスター側へ要求を行うことはできません。</p>
<p>本チュートリアルでいえばCHIRIMEN環境を動かすボードコンピュータがマスターとなり、ここに接続されるセンサーやアクチュエータデバイスなどがスレーブとして想定されます。スレーブデバイスの一例として<a href="https://tutorial.chirimen.org/partslist">こちらに紹介</a>されているI2Cデバイスをご覧ください。</p>
<p>マスターは、スレーブが持つ「SlaveAddress (スレーブアドレス)」を指定して、特定のスレーブとの通信を行います。このため、同じ I2C バス上に同じ SlaveAddress のスレーブを繋ぐことはできません。
I2Cデバイスは小型のICチップデバイスとなっており、デバイスによってはSlaveAddressは製品ごとに固定されています。</p>
<p><img src="./imgs/i2c-bus2.png" alt="i2c-bus2" /></p>
<p>通信するデバイス同士が同一基板上にない場合には、SDA、SCL の 2 本の通信線に加え電源や GND の線を加えて 4 本のケーブルを用いて接続するのが一般的です。電源電圧はデバイスに応じたものを繋ぐ必要があります。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="52-i2cセンサを動作させるsht30編"><a class="header" href="#52-i2cセンサを動作させるsht30編">5.2 I2Cセンサを動作させる（SHT30編）</a></h1>
<p>SHT30は温度に加えて湿度も測定できるI2C接続の多機能センサーです。SHT31もほぼ同等に使えます。(SHT31のほうが精度が高い)</p>
<ul>
<li>
<p><a href="../chirimenGeneric/#i2ci2c--sht30-sht31">SHT30/SHT31について</a></p>
</li>
<li>
<p>ターミナルウィンドの<code>[CHIRIMEN Panel]</code>ボタンを押す</p>
</li>
<li>
<p>出現したCHIRIMEN Panelの<code>[Get Examples]</code>ボタンを押す</p>
</li>
<li>
<p>ID : <a href="https://tutorial.chirimen.org/pizero/esm-examples/#I2C_sht30"><strong>sht30</strong></a> を探します</p>
</li>
<li>
<p>回路図リンクを押すと回路図が出てきますので、回路を組みます。なお、接続は下の図のようになります。
<img src="./imgs/pizero_sht30.png" alt="SHT31 schematic" /></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="521-i2cセンサーsht30の認識を確認して実行する"><a class="header" href="#521-i2cセンサーsht30の認識を確認して実行する">5.2.1 I2Cセンサー(SHT30)の認識を確認して実行する</a></h1>
<h2 id="i2cセンサーsht30が認識されていることを確認する"><a class="header" href="#i2cセンサーsht30が認識されていることを確認する">I2Cセンサー(SHT30)が認識されていることを確認する</a></h2>
<ul>
<li>
<p>CHIRIMEN Panelの<code>[i2c detect]</code>ボタンを押す</p>
<ul>
<li><a href="https://strawberry-linux.com/pub/Sensirion_Humidity_SHT3x_DIS_Datasheet_V3_J.pdf">SHT30 の I2Cアドレス</a>　0x<strong>44</strong>が表示されていればうまく接続されています。</li>
</ul>
</li>
<li>
<p><a href="../chirimenGeneric/#b-i2cdetect">i2c detectとは</a></p>
</li>
</ul>
<p>I2C デバイスが正常に接続されているかどうかを確認するために、ターミナルから <code>i2cdetect</code> というコマンドを使う事ができます。このコマンドは I2C バスをスキャンして反応のあったスレーブアドレスを表示するツールです。</p>
<h3 id="コマンドラインから"><a class="header" href="#コマンドラインから">コマンドラインから</a></h3>
<p>ターミナルから以下のコマンド入力でも同様に確認を行う事が出来ます。</p>
<pre><code class="language-sh">i2cdetect -y -r 1
</code></pre>
<p>i2cdetect を実行したら以下の様にスキャンした結果が CHIRIMENパネルやターミナルに表示されます。</p>
<pre>
     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
00:          -- -- -- -- -- -- -- -- -- -- -- -- --
10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
40: -- -- -- -- 44 -- -- -- -- -- -- -- -- -- -- --
50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
70: -- -- -- -- -- -- -- --
</pre>
<p>0x44 の表示が見えない時は正しく接続がされていません。
回路図を確認して正しく接続が出来ているかを再確認してください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="522-sht30-のコードの取得と実行"><a class="header" href="#522-sht30-のコードの取得と実行">5.2.2 SHT30 のコードの取得と実行</a></h1>
<h2 id="サンプルコードを取得する"><a class="header" href="#サンプルコードを取得する">サンプルコードを取得する</a></h2>
<ul>
<li><code>[JS GET]</code>ボタンを押すと、開発ディレクトリ(<code>~/myApp</code>)に、サンプルコードが保存されます。
<ul>
<li><strong>main-sht30.js</strong>というファイル名で保存されます。</li>
</ul>
</li>
<li>Note: ターミナルウィンドの右側のファイルマネージャで main-sht30.js ⇒編集 を選ぶと、エディタで編集できます。</li>
</ul>
<h2 id="実行する"><a class="header" href="#実行する">実行する</a></h2>
<ul>
<li>ターミナルウィンドのコンソールのプロンプトが<code>pi@raspberrypi:~/myApp$</code>となっていることを確認</li>
<li>ターミナルウィンドのコンソールに、<code>node main-sht30.js</code> [ENTER] と入力して実行。</li>
<li>温度と湿度が1秒ごとにコンソールに表示されます。</li>
<li>終了は CTRL+c</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="523-sht30-のコードを読む"><a class="header" href="#523-sht30-のコードを読む">5.2.3 SHT30 のコードを読む</a></h1>
<ul>
<li>ターミナルウィンドの右側のファイルマネージャでmain-sht30.js⇒表示 を選び、ソースコードを読んでみましょう</li>
</ul>
<pre><code class="language-js">import {requestI2CAccess} from "./node_modules/node-web-i2c/index.js";
import SHT30 from "@chirimen/sht30";
const sleep = msec =&gt; new Promise(resolve =&gt; setTimeout(resolve, msec));

main();

async function main() {
  const i2cAccess = await requestI2CAccess();
  const port = i2cAccess.ports.get(1);
  const sht30 = new SHT30(port, 0x44);
  await sht30.init();

  while (true) {
    const { humidity, temperature } = await sht30.readData();
    console.log(
      [
        `Humidity: ${humidity.toFixed(2)}%`,
        `Temperature: ${temperature.toFixed(2)} degree`
      ].join(", ")
    );

    await sleep(500);
  }
}
</code></pre>
<ul>
<li><a href="../chirimenGeneric/#webi2c">WebI2CライブラリとSHT30デバイスドライバを読み込み</a>
<ul>
<li>I2Cインターフェースに接続されたスレーブデバイスは<a href="http://browserobo.github.io/WebI2C">Web I2C API</a>と呼ぶAPIによって使用することができます。</li>
</ul>
</li>
</ul>
<pre><code class="language-js">import {requestI2CAccess} from "./node_modules/node-web-i2c/index.js";
import SHT30 from "@chirimen/sht30";
</code></pre>
<ul>
<li><a href="./chapter_10-3-1.html">JavaScript module</a> に基づいてWebI2Cライブラリを読み込みます。</li>
<li><a href="./chapter_5-2-4.html">I2C 温湿度センサー (SHT30, SHT31)の初期化と使用</a>
<ul>
<li>次のページでコードの流れを詳細に解説します</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="524-sht30-のコードの詳細解説"><a class="header" href="#524-sht30-のコードの詳細解説">5.2.4 SHT30 のコードの詳細解説</a></h1>
<ul>
<li>I2C 温湿度センサー (SHT30, SHT31)の初期化と使用</li>
</ul>
<pre><code class="language-js">async function main() {
  const i2cAccess = await requestI2CAccess();
  const port = i2cAccess.ports.get(1);
  const sht30 = new SHT30(port, 0x44);
  await sht30.init();

  while (true) {
    const { humidity, temperature } = await sht30.readData();
    temperatureDisplay.innerHTML = `${temperature.toFixed(2)} ℃`;
    humidityDisplay.innerHTML = `${humidity.toFixed(2)} %`;
    await sleep(500);
  }
}
</code></pre>
<p>温度センサーの情報を定期的に取得し、画面に出力する処理が行われています。</br>
少し詳し解説してみます。</p>
<h5 id="await-requesti2caccess"><a class="header" href="#await-requesti2caccess">await requestI2CAccess()</a></h5>
<p>Web I2C API を利用するための <strong><code>I2CAccess</code> インタフェースを取得</strong> するための最初の API 呼び出しです。この関数も非同期処理ですので <code>await</code> で処理完了を待機し、その結果正しくインタフェースが取得されたら <code>i2cAccess</code> オブジェクトに保持します。</p>
<h5 id="i2caccessportsget"><a class="header" href="#i2caccessportsget">i2cAccess.ports.get()</a></h5>
<p><code>I2CAccess.ports</code> は、利用可能な I2C ポートの一覧です。</p>
<pre><code class="language-js">const port = i2cAccess.ports.get(1);
</code></pre>
<p>CHIRIMEN PiZero で利用可能な I2C ポート番号は<code>1</code>番だけです。ポート番号に<code>1</code> を指定して <strong><code>port</code> オブジェクトを取得</strong> しています。</p>
<h5 id="new-sht30port-0x44"><a class="header" href="#new-sht30port-0x44">new SHT30(port, 0x44)</a></h5>
<p>ドライバーライブラリを使い <strong>SHT30 を操作する為のインスタンスを生成</strong> しています。</p>
<pre><code class="language-js">const sht30 = new SHT30(port, 0x44);
</code></pre>
<h5 id="await-sht30init"><a class="header" href="#await-sht30init">await sht30.init()</a></h5>
<p>ドライバーライブラリのインスタンス (<code>sht30</code>) の <code>init()</code> メソッドを通じて <strong>I2C ポートを開いてセンサーを初期化</strong> しています。</p>
<pre><code class="language-js">await sht30.init();
</code></pre>
<p>具体的に内部では、インスタンス生成時に指定した <code>port</code> オブジェクトと <code>slaveAddress(0x44)</code> を用いて <code>I2CPort.open()</code> を行なっています。<code>I2CPort.open()</code> が成功すると、<code>I2CSlaveDevice</code> という I2C ポートへデータ書き込みや読み込みなどを行うインタフェースが返されます。<code>I2CSlaveDevice</code> インタフェースは、ライブラリ内に保存され、その後の処理でこのインターフェイスを使って I2C デバイス SHT30 との通信が可能になります。</p>
<h5 id="await-sht30readdata"><a class="header" href="#await-sht30readdata">await sht30.readData()</a></h5>
<p>実際にデータを読み取っています。 この読み取り関数はGPIOで紹介した、一回きりの単純入力に相当するものです。そのため連続的な変化を知りたい場合はポーリングルーチンを組む必要があります。
<strong>SHT30 の仕様に基づくデータ読み出し処理です</strong>。</p>
<pre><code class="language-js">const { humidity, temperature } = await sht30.readData();
</code></pre>
<p>ドライバーライブラリ内部では、SHT30 から得られる温度と湿度それぞれ 16bit の数値を、温度・湿度の物理量の数値に変換して返却しています。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="53-adt7410編"><a class="header" href="#53-adt7410編">5.3 ADT7410編</a></h1>
<p>温度センサーADT7410を使います。
もし、SHT30を使用する場合は、「<a href="./chapter_6.html">6. IoTを試す</a>」の章まで読み飛ばしてください。</p>
<ul>
<li>ターミナルウィンドの<code>[CHIRIMEN Panel]</code>ボタンを押す</li>
<li>出現したCHIRIMEN Panelの<code>[Get Examples]</code>ボタンを押す</li>
<li>ID : adt7410を探します(上から5個目ぐらい)</li>
<li>回路図リンクを押すと回路図が出てきますので、回路を組みます。なお、接続は下の図のようになります。
<ul>
<li><a href="https://tutorial.chirimen.org/raspi/hellorealworld#section-2">センサーの極性に注意！</a></li>
</ul>
</li>
</ul>
<p><img src="./imgs/pizero_temp.png" alt="PiZero温度センサー図" /></p>
<ul>
<li><code>[JS GET]</code>ボタンを押すと、開発ディレクトリ(<code>~/myApp</code>)に、サンプルコードが保存されます。
<ul>
<li><strong>main-adt7410.js</strong>というファイル名で保存されます。</li>
<li>Note: ターミナルウィンドの右側のファイルマネージャでmain-adt7410.js⇒編集 を選ぶと、エディタで編集できます。
<ul>
<li>ソースコードを見てみましょう</li>
<li>今は編集不要ですが、サンプルをベースに応用プログラムを作るときには編集しましょう。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="i2cセンサーが認識されていることを確認する"><a class="header" href="#i2cセンサーが認識されていることを確認する">I2Cセンサーが認識されていることを確認する</a></h3>
<ul>
<li>CHIRIMEN Panelの<code>[i2c detect]</code>ボタンを押すと、<a href="https://akizukidenshi.com/download/ds/akizuki/AE-ADT7410_aw.pdf">ADT7410のI2Cアドレス</a>　0x<strong>48</strong>が表示されていればうまく接続されています。
<ul>
<li><a href="https://tutorial.chirimen.org/ty51822r3/i2cdetect">i2c detectとは</a></li>
</ul>
</li>
</ul>
<pre>
     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
00:          -- -- -- -- -- -- -- -- -- -- -- -- --
10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
40: -- -- -- -- -- -- -- -- 48 -- -- -- -- -- -- --
50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
70: -- -- -- -- -- -- -- --
</pre>
<h3 id="実行する-1"><a class="header" href="#実行する-1">実行する</a></h3>
<ul>
<li>ターミナルウィンドのコンソールのプロンプトが<code>pi@raspberrypi:~/myApp$</code>となっていることを確認</li>
<li>ターミナルウィンドのコンソールに、<code>node main-adt7410.js</code> [ENTER] と入力して実行。</li>
<li>温度が1秒ごとにコンソールに表示されます。</li>
<li>終了は CTRL+c</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="54-gpio-と-i2cセンサーを組み合わせる"><a class="header" href="#54-gpio-と-i2cセンサーを組み合わせる">5.4 GPIO と I2Cセンサーを組み合わせる</a></h1>
<p>GPIO センサーと I2Cセンサーは、それぞれを組み合わせて動作させることも可能です。このチュートリアルで使用した LED（GPIOセンサー）と SHT30温湿度センサー（I2Cセンサー）を組み合わせて、決まった温度になったら LED を光らせるサンプルを試してみましょう。</p>
<p><code>CHIRIMEN パネル</code> の <code>Get Examples</code> の中より ID: <a href="https://tutorial.chirimen.org/pizero/esm-examples/#I2C_sht30_led"><strong>sht30_led</strong></a> を参考にして回路図の確認やサンプルコードを取得して動作を確認してみましょう。</p>
<p><img src="./imgs/SHT30_LED.png" alt="配線図 SHT30 温湿度センサー + LED" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="6-iotを試す"><a class="header" href="#6-iotを試す">6. IoTを試す</a></h1>
<p><img src="imgs/IoTsystemConf.png" alt="system configuration" />
IoT は、制御されるデバイス（上図では <strong>CHIRIMEN PiZero W</strong> ）と、利用者端末（上図では <strong>WebApp PC-side</strong> ）に加えて、これらの間でデータを中継するサーバ（<strong>クラウド</strong>）が必要になります。
今回は Web標準技術である WebSocketプロトコルを中継するサーバを用いて LED を備えた CHIRIMENデバイスと、スマホや PC の WebApp を繋いだ IoTシステムを作ります。</p>
<p>Note: <a href="./chapter_4-2.html">モーター制御の回路</a>を組めば、そのまま遠隔モーターコントロールができます</p>
<p>用語の詳細な説明は共通資料で解説を行っていますので、興味のある方はそちらをご確認ください。</p>
<ul>
<li><a href="./chapter_10-6.html">IoT</a></li>
<li><a href="./chapter_10-6.html">WebSoeketとRelayServer</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="61-遠隔ledコントロール"><a class="header" href="#61-遠隔ledコントロール">6.1 遠隔LEDコントロール</a></h1>
<h2 id="配線する"><a class="header" href="#配線する">配線する</a></h2>
<p>配線は最初の Lチカそのままです。
<img src="./imgs/pizero_led.png" alt="PiZero配線図" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="62-pizero-サンプルコードの実行"><a class="header" href="#62-pizero-サンプルコードの実行">6.2 PiZero サンプルコードの実行</a></h1>
<p>IoT の実行を行う為に PiZero 用のサンプルコードの実行と、PC 用のサンプルコードの実行が必要になります。それぞれのコードの実行方法は以下を参考に実施してください。</p>
<h2 id="chirimenデバイス側にコードを入れ実行する"><a class="header" href="#chirimenデバイス側にコードを入れ実行する">CHIRIMENデバイス側にコードを入れ、実行する</a></h2>
<ul>
<li>ターミナルウィンドの<code>[CHIRIMEN Panel]</code>ボタンを押す</li>
<li>出現したCHIRIMEN Panelの<code>[Get Examples]</code>ボタンを押す</li>
<li>ID : <strong>remote_gpio_led</strong>の行を探します（もう一度この行の情報を使います）</li>
<li><code>[JS GET]</code>ボタンを押すと、開発ディレクトリ(<code>~/myApp</code>)に、サンプルコードが保存されます。
<ul>
<li><strong>main-remote_gpio_led.js</strong>というファイル名で保存されます。</li>
<li>ターミナルウィンドの右側のファイルマネージャでmain-remote_gpio_led.js⇒編集 を選びソースコードを見てみましょう</li>
</ul>
</li>
<li>実行する
<ul>
<li>ターミナルウィンドのコンソールのプロンプトが<code>pi@raspberrypi:~/myApp$</code>となっていることを確認</li>
<li>ターミナルウィンドのコンソールに、<code>node main-remote_gpio_led.js</code> [ENTER] と入力して実行。
<img src="imgs/RC_NODE.png" alt="CHIRIMEN PiZero Console" /></li>
<li>なお、実験が終わったら終了は CTRL+c です。</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="63-pc-サンプルコードの実行"><a class="header" href="#63-pc-サンプルコードの実行">6.3 PC サンプルコードの実行</a></h1>
<ul>
<li>
<p>CHIRIMEN Panel に戻り、ID : <strong>remote_gpio_led</strong> の行にある、<code>CSB EDIT</code> リンクをクリックする。</p>
<ul>
<li>CodeSandbox というオンラインの WebApp開発環境のウィンドが開き、PC側のコードの表示と実行がされています。
<ul>
<li>CodeSandbox を使って編集もできます。</li>
<li>詳しい解説：<a href="https://csb-jp.github.io/">CodeSandbox ガイド</a></li>
</ul>
</li>
<li>参考画像では右側のフレームに LED を遠隔コントロールするための WebApp が既に実行されています。</li>
<li>WebApp を使って LED が制御できることを確かめてみましょう。</li>
</ul>
</li>
<li>
<p>CodeSandbox の画面構成について
<img src="imgs/RC_CSB.svg" alt="Code Sandbox Image" /></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="64-自分専用チャンネルで制御"><a class="header" href="#64-自分専用チャンネルで制御">6.4 自分専用チャンネルで制御</a></h1>
<p>サンプルのコードは共通のチャンネルを使って制御しています。この状態では複数の人が同時に実習していると混信します。(他の人のPCでON/OFFを指示しても、自分のLEDがON/OFFする。同じチャンネルを使っているため。)</p>
<p>これはこれで使い道はあるのですが、自分のLEDは自分だけで制御したい場合は専用のチャンネルを使って制御しましょう。　チャンネルの指定はPiZero側のコードと、PC側のコード両方を同時に同じ内容で設定する必要があり、以下の部分になります。</p>
<p><code>channel = await relay.subscribe("chirimenLED");</code></p>
<p>この<code>chirimenLED</code>という文字列(チャンネル名)を他の人と被らない別のチャンネル名に書き換えます(<code>chirimenLED5</code>など)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="65-pizero-側のコードを読む"><a class="header" href="#65-pizero-側のコードを読む">6.5 PiZero 側のコードを読む</a></h1>
<h2 id="raspberry-pi-zero側コード"><a class="header" href="#raspberry-pi-zero側コード">Raspberry Pi Zero側コード</a></h2>
<ul>
<li>ターミナルウィンドの右側のファイルマネージャでmain-remote_gpio_led.js⇒表示 を選び、ソースコードを読んでみましょう</li>
</ul>
<pre><code class="language-js">import {requestGPIOAccess} from "./node_modules/node-web-gpio/dist/index.js";
const sleep = msec =&gt; new Promise(resolve =&gt; setTimeout(resolve, msec));
import nodeWebSocketLib from "websocket"; // https://www.npmjs.com/package/websocket
import {RelayServer} from "./RelayServer.js";

var channel;
var gpioPort0;

async function connect(){
	// GPIOポート0の初期化
	var gpioAccess = await requestGPIOAccess();
	var mbGpioPorts = gpioAccess.ports;
	gpioPort0 = mbGpioPorts.get(26);
	await gpioPort0.export("out"); //port0 out

	// webSocketリレーの初期化
	var relay = RelayServer("chirimentest", "chirimenSocket" , nodeWebSocketLib, "https://chirimen.org");
	channel = await relay.subscribe("chirimenLED");
	console.log("web socketリレーサービスに接続しました");
	channel.onmessage = controlLED;
}

function controlLED(messge){
	console.log(messge.data);
	if ( messge.data =="LED ON"){
		gpioPort0.write(1);
		console.log("ON");
		channel.send("LEDをオンにしました");
	} else if ( messge.data =="LED OFF"){
		gpioPort0.write(0);
		console.log("OFF");
		channel.send("LEDをオフにしました");
	}
}

connect();
</code></pre>
<p>プログラムは以下の流れで実行されています。</p>
<ul>
<li>これまで通りWebGPIOライブラリの読み込み</li>
<li><a href="./chapter_10-6.html">relayServer.js</a>ライブラリの読み込み
<ul>
<li>Node.jsではrelayServerライブラリに加えて、webSocketライブラリの読み込みが必要です。</li>
</ul>
</li>
</ul>
<pre><code class="language-js">import nodeWebSocketLib from "websocket";
import {RelayServer} from "./RelayServer.js";
</code></pre>
<ul>
<li><a href="./chapter_10-6.html">relayServer.js</a>を使って、PCからの操作指示を受信
<ul>
<li><a href="./chapter_10-6.html">初期化</a></li>
<li><a href="./chapter_10-6.html">受信処理</a>(コールバック関数の設定)</li>
</ul>
</li>
<li>受信した内容をもとに<a href="./chapter_10-6.html">GPIO出力を操作</a>してLEDを点灯・消灯</li>
</ul>
<p>コードの詳細解説は<a href="./chapter_10-6.html">こちら</a>を参照してください</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="66-pc-側のコードを読む"><a class="header" href="#66-pc-側のコードを読む">6.6 PC 側のコードを読む</a></h1>
<h2 id="pc側コード"><a class="header" href="#pc側コード">PC側コード</a></h2>
<ul>
<li>CodeSandboxで開いている <code>PC.js</code> を見てみましょう</li>
</ul>
<pre><code class="language-js">// Remote Example4 - controller
import {RelayServer} from "https://chirimen.org/remote-connection/js/beta/RelayServer.js";

window.OnLED = OnLED;
window.OffLED = OffLED;

var channel;
onload = async function(){
	// webSocketリレーの初期化
	var relay = RelayServer("chirimentest", "chirimenSocket" );
	channel = await relay.subscribe("chirimenLED");
	messageDiv.innerText="web socketリレーサービスに接続しました";
	channel.onmessage = getMessage;
}

function getMessage(msg){ // メッセージを受信したときに起動する関数
	messageDiv.innerText = msg.data;
}

function OnLED(){ // LED ON
	channel.send("LED ON");
}
function OffLED(){ // LED OFF
	channel.send("LED OFF");
}
</code></pre>
<p>プログラムは以下の流れで実行されています。</p>
<ul>
<li><a href="./chapter_10-3-1.html">JavaScript Module</a>仕様に基づいて <code>relayServer.js</code> を読み込み</li>
</ul>
<pre><code class="language-js">import {RelayServer} from "https://chirimen.org/remote-connection/js/beta/RelayServer.js";
</code></pre>
<ul>
<li><a href="../chirimenGeneric/#relayserverjs">relayServer.js</a>を使い、UIを通してユーザからの操作指示を送信
<ul>
<li><a href="./chapter_10-6.html">初期化</a></li>
<li><a href="./chapter_10-6.html">送信処理</a>～（UI(ボタン)に設置したコールバック関数をもとに送信</li>
</ul>
</li>
</ul>
<p>コードの詳細解説は<a href="./chapter_10-6.html">こちら</a>を参照してください</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="7-常駐プログラム化する"><a class="header" href="#7-常駐プログラム化する">7. 常駐プログラム化する</a></h1>
<p>ターミナルウィンドからnodeコマンドで実行指示しなくても、電源投入後 自動的に指定したコードを起動する設定（常駐プログラム化）ができます。</br>
このチュートリアルでは、<a href="https://www.npmjs.com/package/forever">forever</a> を使用する設定を専用GUIを用いて行ってみましょう。</p>
<p><img src="./imgs/residentappconf.jpg" alt="Resident App Conf." /></p>
<ul>
<li>
<p>ターミナルウィンドの <code>[CHIRIMEN Panel]</code> ボタン ⇒ CHIRIMEN Panel の <code>[Resident App Conf.]</code> ボタンを押します。</p>
<ul>
<li>専用画面の UI が使用可能状態になるまで数秒かかります。</li>
</ul>
</li>
<li>
<p>開発ディレクトリ<code>~/myApp</code>内にある JavaScript コードがリストアップされます。</p>
</li>
<li>
<p>各行の <code>Now Running</code> 列は常駐状態、<code>App Name</code>はコードのファイル名、<code>Select</code> は選択用チェックボックスです。</p>
<ul>
<li><code>Now Running</code>欄には現在常駐プログラム化しているコードに、<code>RUNNING</code>が表示されています。（常駐プログラムがなければ全部の行が空白になります）</li>
<li><code>Select</code>欄のチェックボックスをチェックすると、そのコードが常駐プログラム化します。（常駐プログラムは一個だけ指定できます）
<ul>
<li>設定が反映され、常駐状態が確認できるようになるまで、２０秒ぐらいかかります
<ul>
<li>常駐状態の再確認は<code>[Resident App Conf.]</code>ボタンで可能</li>
<li>設定できたらシャットダウンしてPCとのUSB接続も外します
<ul>
<li>シャットダウンコマンド: <code>sudo shutdown -h now</code></li>
</ul>
</li>
<li>その後PiZeroをモバイルバッテリなどにつないで独立して稼働させます。
<ul>
<li>PiZeroの緑色LEDの点滅が収まると、概ね常駐プログラムが起動</li>
<li>その後PCからリモートコントロールしてみましょう</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>PCに接続しなおして、一番上の <code>STOP ALL APPS</code> のチェックボックスをチェックすると、常駐プログラムを解除できます。</li>
</ul>
</li>
<li>
<p><em>Note: 常駐化のツールとしては、他にも systemd service unit, openrc, cron, pm2, forever 等があります。Webでそれぞれの特徴を調べて用途に合ったものを選択して設定しても良いでしょう。</em></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="8-他のいろいろなデバイスを試してみる"><a class="header" href="#8-他のいろいろなデバイスを試してみる">8. 他のいろいろなデバイスを試してみる</a></h1>
<ul>
<li>ターミナルウィンドの <code>[CHIRIMEN Panel]</code> ボタン ⇒ CHIRIMEN Panelの <code>[Get Examples]</code> ボタンで出現するリストのデバイスがすぐ試せます。</li>
<li>このリストの直リンクは<a href="https://tutorial.chirimen.org/pizero/esm-examples/">こちら(サンプル一覧)</a>です。CHIRIMEN RPiZero を PC につないでいないときはこちらを眺めてください。</li>
</ul>
<p>また、こちらには、Web GPIO や Web I2C によって扱うことのできる<a href="https://tutorial.chirimen.org/raspi/partslist">外部デバイスの写真や様々なCHIRIMEN環境のサンプルコードの一覧があります</a>。こちらも参考になるかもしれません。</br>(CHIRIMENは<a href="https://tutorial.chirimen.org/">Raspberry Pi ZeroW 以外に、Raspberry Pi3, Pi4 や、micro:bit等</a>)でも使用できます）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="81-応用センサーキットの使い方"><a class="header" href="#81-応用センサーキットの使い方">8.1 応用センサーキットの使い方</a></h1>
<h2 id="応用センサーキットの一覧"><a class="header" href="#応用センサーキットの一覧">応用センサーキットの一覧</a></h2>
<img src="./imgs/AppliedSensorKits.jpg" width=800>
<h2 id="目次-1"><a class="header" href="#目次-1">目次</a></h2>
<ul>
<li><a href="./chapter_8-1-1.html">単体で動作確認できるセンサーの使い方</a>
<ul>
<li>距離センサー／照度センサー／温湿度・気圧センサー／非接触赤外線温度センサー／サーモグラフィー</li>
</ul>
</li>
<li><a href="./chapter_8-1-2.html">人感センサーの使い方</a></li>
<li><a href="./chapter_8-1-3.html">Neopixel LED の使い方</a></li>
<li><a href="./chapter_8-1-4.html">アナログセンサーの使い方</a></li>
<li><a href="./chapter_8-1-5.html">アクチュエーター（サーボモーター）の使い方</a></li>
<li>アクチュエーター（DCモーター）の使い方
<ul>
<li><a href="./chapter_8-1-6.html">hbridge1 の回路図（MX1508利用）</a></li>
<li><a href="./chapter_8-1-7.html">hbridge2-pca9685pwm の回路図（MX1508利用）</a></li>
</ul>
</li>
<li><a href="./chapter_8-1-8.html">RaspberryPi のカメラに関する注意</a></li>
</ul>
<hr />
<ul>
<li>応用センサーキットはハッカソン等のアイディアを実装する際に使い勝手の良いセンサーを集めたキットです。</li>
<li>CHIRIMEN チュートリアルで習得したスキルを使って実際に動作させることが出来ます。</li>
<li>一部のセンサーは特性を知る必要があるのでその解説を行います。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="811-単体で動作確認できるセンサー"><a class="header" href="#811-単体で動作確認できるセンサー">8.1.1 単体で動作確認できるセンサー</a></h1>
<img src="./imgs/I2Csensor.jpg" width=800>
<ul>
<li>I2C Examples より回路図とサンプルコードを使って試すことが出来ます。
<ul>
<li>上記のセンサーのカッコ内はセンサーの型番で、Examples の ID と同じ記載になります。</li>
<li>上記のセンサーはそれぞれ単体で使う事が出来ます。</li>
</ul>
</li>
</ul>
<h3 id="回路図とプログラムサンプル"><a class="header" href="#回路図とプログラムサンプル">回路図とプログラムサンプル</a></h3>
<p><img src="./imgs/Vl53l0x.jpg" width=450> <img src="./imgs/Vl53l0x2.jpg" width=200></p>
<p>動作を確認するためのサンプルコードは <code>CHIRIMENパネル</code> から入手できます。<br>
ブラウザでサンプルコードの中を確認したい場合は <code>コードを確認する</code> から確認出来ます。</p>
<ul>
<li>レーザー距離センサー ＞ <strong>ID：vl53l0x　タイトル：距離センサ</strong>
<ul>
<li><a href="https://tutorial.chirimen.org/pizero/esm-examples/vl53l0x/main.js">※コードを確認する</a></li>
</ul>
</li>
<li>照度センサー ＞ <strong>ID：bh1750　タイトル：照度センサ</strong>
<ul>
<li><a href="https://tutorial.chirimen.org/pizero/esm-examples/bh1750/main.js">※コードを確認する</a></li>
</ul>
</li>
<li>温湿度・気圧センサー ＞ <strong>ID：bme280　タイトル：温度・湿度・気圧</strong>
<ul>
<li><a href="https://tutorial.chirimen.org/pizero/esm-examples/bme280/main.js">※コードを確認する</a></li>
</ul>
</li>
<li>非接触赤外線温度センサー ＞ <strong>ID：mlx90614 タイトル：赤外線温度センサ</strong>
<ul>
<li><a href="https://tutorial.chirimen.org/pizero/esm-examples/mlx90614/main.js">※コードを確認する</a></li>
</ul>
</li>
<li>サーモグラフィー ＞ <strong>ID：amg8833　タイトル：サーモグラフィー</strong>
<ul>
<li><a href="https://tutorial.chirimen.org/pizero/esm-examples/amg8833/main.js">※コードを確認する</a></li>
</ul>
</li>
</ul>
<p>【注意！】回路図と実物のセンサーは製品によって形状が異なる場合があります。</p>
<ul>
<li>実際の応用センサーキットに入っている距離センサーは写真の物となります。
<ul>
<li>写真のレーザーセンサーを基板の表記に合わせた接続例です。回路図と同じ色のジャンパーワイヤーで接続します。</li>
</ul>
</li>
<li>I2C センサーは例の図の基盤に書かれた 4つのピン（<strong>VIN / GND / SCL / SDA</strong>）を接続するのが基本となります。</li>
</ul>
<pre><code>※注意
回路図のセンサー画像は形は異なっていますが、写真の部品と同じセンサーを示しています。センサーは物により形状が異なる物がありますが搭載されたチップが同じになります。
形状が異なる場合は実物の基板に書かれた文字を確認して、回路図と同じ文字の書かれたピンに接続します。
センサーのピンは接続しない部分も物によってあります。回路図に従って必要な部分を繋ぎます。必ずセンサーの全てのピンを繋ぐ必要はありません。
</code></pre>
<p><a href="./chapter_8-1.html">応用センサー一覧に戻る</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="812-人感センサーの使い方"><a class="header" href="#812-人感センサーの使い方">8.1.2 人感センサーの使い方</a></h1>
<p><img src="./imgs/pir_sensor_photo.jpg" width=300> <img src="./imgs/pir_sensor_use.jpg" width=400></p>
<ul>
<li>人感センサーは半球体の部分から赤外線が発されて人の動きや熱を検知してオンオフするセンサーです。</li>
<li>人感センサーは GPIO センサーとなり、チュートリアルのスイッチと同じ種類のセンサーになります。</li>
<li>センサーに感度と保持時間を調整するつまみがあるので調節してテストしてください。
<ul>
<li>つまみの調整に精密ドライバーを利用します</li>
</ul>
</li>
<li>人感センサーは広範囲でセンサーが反応しますので、人の居ない方に向けて、自分もなるべくセンサーから離れて動作確認するようにしてください。</li>
<li>動作確認をする際には保持時間を最短にすると調整しやすくなります。</li>
</ul>
<h3 id="回路図とプログラムサンプル-1"><a class="header" href="#回路図とプログラムサンプル-1">回路図とプログラムサンプル</a></h3>
<img src="./imgs/pir_sensor.jpg" width=600>
<p>動作を確認するためのサンプルコードは <code>CHIRIMENパネル</code> から入手できます。
ブラウザでサンプルコードの中を確認したい場合は <code>コードを確認する</code> から確認出来ます。</p>
<ul>
<li>人感センサー ＞ <strong>ID：gpio-onchange　タイトル：スイッチ</strong>
<ul>
<li><a href="https://tutorial.chirimen.org/pizero/esm-examples/gpio-onchange/main.js">※コードを確認する</a></li>
</ul>
</li>
<li>人感センサー ＞ <strong>ID：gpio-polling　タイトル：スイッチ2</strong>
<ul>
<li><a href="https://tutorial.chirimen.org/pizero/esm-examples/gpio-polling/main.js">※コードを確認する</a></li>
</ul>
</li>
</ul>
<p>【備考】</p>
<ul>
<li><a href="https://chirimen.org/chirimen/gc/top/examples/#GPIO-pirSensor">参考情報 ※CHIRIMEN Pi4 版</a></li>
<li>サンプルコードは「スイッチ」のソースコードと共通で利用する事が出来ます。人感センサー（pir sensor）の名前でサンプル一覧には掲載されていないので注意してください。</li>
<li>「スイッチ2」のソースコードでも動作させることが可能で、こちらは逐一センサーの状況が分かるので、調整をする際にはこちらのサンプルを利用すると便利です。</li>
</ul>
<p><a href="./chapter_8-1.html">応用センサー一覧に戻る</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="813-neopixel-led-の使い方"><a class="header" href="#813-neopixel-led-の使い方">8.1.3 Neopixel LED の使い方</a></h1>
<img src="./imgs/NeopixelLEDset.jpg" width=600>
<ul>
<li>Neopixel LED というフルカラーLED の使い方です。こちらの LED はチュートリアルの LED と異なり、プログラムで複数の LED の点灯の制御や色を変えたりすることが出来ます。</li>
<li>接続には Neopixel I2C Driver というオープンハードウェアを利用しています。このドライバーボードは市販品ではありません。</li>
</ul>
<h3 id="回路図とプログラムサンプル-2"><a class="header" href="#回路図とプログラムサンプル-2">回路図とプログラムサンプル</a></h3>
<img src="./imgs/NeopixelLED.jpg" width=800>
<p>※ドライバとLEDの接続をする部分は以下の通りです。
　赤：VIN（3.3V）, 黒：GND, 緑：D-IN（DI）
　既にケーブルが接続されている物は同系色のケーブルを繋げます。</p>
<p>動作を確認するためのサンプルコードは <code>CHIRIMENパネル</code> から入手できます。<br>
ブラウザでサンプルコードの中を確認したい場合は <code>コードを確認する</code> から確認出来ます。</p>
<ul>
<li>NEOPIXEL LED（8連LED／16連LED） ＞ <strong>ID：neopixel-i2c　タイトル：NEOPIXEL LED</strong>
<ul>
<li><a href="https://tutorial.chirimen.org/pizero/esm-examples/neopixel-i2c/main.js">※コードを確認する</a></li>
</ul>
</li>
</ul>
<p>【備考】</p>
<ul>
<li>専用コントローラーボード Neopixel I2C Driver を使った接続をすると簡単に使う事が出来ます。
<ul>
<li>Neopixel I2C Driver は<a href="https://github.com/chirimen-oh/accessories/blob/master/others/neopixel_i2c_TH/">オープンソースハードで、市販品ではありません。</a></li>
</ul>
</li>
<li>センサーを使う時には図のように赤色のドライバボードと NeoPixel LED をペアで利用して試してください。
<ul>
<li>Neopixel LED は様々なサイズ、形で商品が出ています。（丸形、棒型、マトリクス型、テープ型　等）</li>
</ul>
</li>
</ul>
<div style="page-break-before:always"></div>
<p><a href="./chapter_8-1.html">応用センサー一覧に戻る</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="814-アナログセンサーの使い方"><a class="header" href="#814-アナログセンサーの使い方">8.1.4 アナログセンサーの使い方</a></h1>
<p><img src="./imgs/analog_sensor.jpg" width=500><img src="./imgs/water_soil.jpg" width=300></p>
<ul>
<li>アナログセンサーを利用する時には ADC（アナログデジタルコンバーター）を利用して値を取得して使います。</li>
<li>応用センサーキットでは半固定抵抗（つまみの代わり）を利用したアナログ値の変更の確認をするサンプルと、水位センサー・土壌湿度センサーがキットに含まれています。</li>
</ul>
<h3 id="回路図とプログラムサンプル-3"><a class="header" href="#回路図とプログラムサンプル-3">回路図とプログラムサンプル</a></h3>
<h2 id="アナログボリュームの回路図半固定抵抗利用"><a class="header" href="#アナログボリュームの回路図半固定抵抗利用">アナログボリュームの回路図（半固定抵抗利用）</a></h2>
<img src="./imgs/analog_jig.jpg" width=700>
<ul>
<li>アナログセンサーの利用は ADS1115 を使います。回路図にあるつまみは半固定抵抗 10KΩ を使用します。</li>
</ul>
<p>動作を確認するためのサンプルコードは <code>CHIRIMENパネル</code> から入手できます。<br>
ブラウザでサンプルコードの中を確認したい場合は <code>コードを確認する</code> から確認出来ます。</p>
<ul>
<li>アナログボリューム ＞ <strong>ID：ads1x15　タイトル：電圧測定（ADC）</strong>
<ul>
<li><a href="https://tutorial.chirimen.org/pizero/esm-examples/ads1x15/main.js">※コードを確認する</a></li>
</ul>
</li>
</ul>
<p>【備考】</p>
<ul>
<li>サンプルコードはアナログの値を電力に変換して表示させています。
<ul>
<li>電力変化量から必要な値を求められるようにするのは、プログラムでの計算が必要です。</li>
</ul>
</li>
<li>水位センサー／土壌センサーを利用する前にアナログボリュームで動作確認をするようにしてください。</li>
</ul>
<h2 id="水位センサーの回路図"><a class="header" href="#水位センサーの回路図">水位センサーの回路図</a></h2>
<img src="./imgs/analog_water.jpg" width=700>
<ul>
<li>水位センサ、土壌湿度センサもアナログセンサーです。ADS1115 を併用して使います。</li>
</ul>
<p>動作を確認するためのサンプルコードは <code>CHIRIMENパネル</code> から入手できます。<br>
ブラウザでサンプルコードの中を確認したい場合は <code>コードを確認する</code> から確認出来ます。</p>
<ul>
<li>アナログ水位センサー／アナログ土壌センサー ＞ <strong>ID：ads1x15　タイトル：電圧測定（ADC）</strong>
<ul>
<li><a href="https://tutorial.chirimen.org/pizero/esm-examples/ads1x15/main.js">※コードを確認する</a></li>
</ul>
</li>
</ul>
<p>【備考】</p>
<ul>
<li>動作を確認するためには実際に水につけて確認するか、濡れタオルで覆う事で確認が出来ます。</li>
</ul>
<p><a href="./chapter_8-1.html">応用センサー一覧に戻る</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="815-アクチュエーターサーボモーターの使い方"><a class="header" href="#815-アクチュエーターサーボモーターの使い方">8.1.5 アクチュエーター（サーボモーター）の使い方</a></h1>
<img src="./imgs/pwm_sg90.jpg" width=700>
<ul>
<li>モーターを使用する場合はモータードライバーを経由して制御します。</li>
<li>モーターを動かすため外部から電力を取る必要があります。</li>
</ul>
<h3 id="回路図とプログラムサンプル-4"><a class="header" href="#回路図とプログラムサンプル-4">回路図とプログラムサンプル</a></h3>
<img src="./imgs/pca9685_sg90.jpg" width=700>
<p>動作を確認するためのサンプルコードは <code>CHIRIMENパネル</code> から入手できます。<br>
ブラウザでサンプルコードの中を確認したい場合は <code>コードを確認する</code> から確認出来ます。</p>
<ul>
<li>アクチュエーター（サーボモーター） ＞ <strong>ID：pca9685　タイトル：サーボモータ</strong>
<ul>
<li><a href="https://tutorial.chirimen.org/pizero/esm-examples/pca9685/main.js">※コードを確認する</a></li>
</ul>
</li>
</ul>
<p>【備考】</p>
<ul>
<li>給電方法は電池ボックス又は USB DIP 化キットを使ったモバイルバッテリーの使用、電源モジュールを使った ACアダプタ給電などを使用します。</li>
<li>サーボドライバーの給電接続には精密ドライバーを使用します</li>
</ul>
<h2 id="モバイルバッテリーの利用方法"><a class="header" href="#モバイルバッテリーの利用方法">モバイルバッテリーの利用方法</a></h2>
<img src="./imgs/mobilebattery.jpg" width=500>
<ul>
<li>microUSB DIP化キットを使用してモバイルバッテリーを電池ボックスとして使用する事が出来ます。</li>
<li>電源として利用するだけであれば、VIN と GND の 2ヶ所にジャンパーワイヤーを使用して接続が出来ます。</li>
</ul>
<h2 id="pizero-から給電する回路図"><a class="header" href="#pizero-から給電する回路図">PiZero から給電する回路図</a></h2>
<img src="./imgs/pca9685_sg90_nodc.jpg" width=600>
<ul>
<li>低消費電力のモーター（例：SG-90）1個の場合、RasPi Zero からの電力供給でも動作させられるものもあります。</li>
</ul>
<p><a href="./chapter_8-1.html">応用センサー一覧に戻る</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="816-アクチュエーターdcモーターの使い方"><a class="header" href="#816-アクチュエーターdcモーターの使い方">8.1.6 アクチュエーター（DCモーター）の使い方</a></h1>
<img src="./imgs/dcmotor.jpg" width=600>
<ul>
<li>モーターを使用する場合はモータードライバーを経由して制御します。</li>
<li>モーターを動かすため外部から電力を取る必要があります。
<ul>
<li>このサンプルは PiZero から外部電力を給電しています。</li>
</ul>
</li>
</ul>
<h3 id="回路図とプログラムサンプル-5"><a class="header" href="#回路図とプログラムサンプル-5">回路図とプログラムサンプル</a></h3>
<h2 id="hbridge1-の回路図mx1508利用"><a class="header" href="#hbridge1-の回路図mx1508利用">hbridge1 の回路図（MX1508利用）</a></h2>
<img src="./imgs/MX1508_DCmotor.jpg" width=700>
<ul>
<li>このサンプルは GPIO Examples のサンプルです。</li>
</ul>
<p>動作を確認するためのサンプルコードは <code>CHIRIMENパネル</code> から入手できます。<br>
ブラウザでサンプルコードの中を確認したい場合は <code>コードを確認する</code> から確認出来ます。</p>
<ul>
<li>アクチュエーター（DCモーター） ＞ <strong>ID：hbridge1　タイトル：モータ正転・逆転制御</strong>
<ul>
<li><a href="https://tutorial.chirimen.org/pizero/esm-examples/hbridge1/main.js">※コードを確認する</a></li>
</ul>
</li>
</ul>
<p>【備考】</p>
<ul>
<li>L298N と同様に動作する MX1508 で接続した回路図を掲載します。
<ul>
<li>モーターの動作にジャンパーワイヤー等の他の物を巻き込まない様に、動作前にモーター周りを注意確認してください。</li>
</ul>
</li>
</ul>
<p><a href="./chapter_8-1.html">応用センサー一覧に戻る</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="817-アクチュエーターdcモーターの使い方pwm駆動"><a class="header" href="#817-アクチュエーターdcモーターの使い方pwm駆動">8.1.7 アクチュエーター（DCモーター）の使い方（PWM駆動）</a></h1>
<img src="./imgs/dcmotor2.jpg" width=600>
<ul>
<li>モーターを使用する場合はモータードライバーを経由して制御します。</li>
<li>モーターを動かすため外部から電力を取る必要があります。</li>
</ul>
<h3 id="回路図とプログラムサンプル-6"><a class="header" href="#回路図とプログラムサンプル-6">回路図とプログラムサンプル</a></h3>
<h2 id="hbridge2-pca9685pwm-の回路図mx1508利用"><a class="header" href="#hbridge2-pca9685pwm-の回路図mx1508利用">hbridge2-pca9685pwm の回路図（MX1508利用）</a></h2>
<img src="./imgs/MX1508_PWM_DCmotor.jpg" width=700>
<ul>
<li>このサンプルは I2C Examples になります。</li>
</ul>
<p>動作を確認するためのサンプルコードは <code>CHIRIMENパネル</code> から入手できます。<br>
ブラウザでサンプルコードの中を確認したい場合は <code>コードを確認する</code> から確認出来ます。</p>
<ul>
<li>人感センサー ＞ <strong>ID：hbridge2-pca9685pwm　タイトル：モータ正転・逆転・速度制御</strong>
<ul>
<li><a href="https://tutorial.chirimen.org/pizero/esm-examples/gpio-onchange/main.js">※コードを確認する</a></li>
</ul>
</li>
</ul>
<p>【備考】</p>
<ul>
<li>PWMサーボドライバーと組み合わせた動作の場合は、PWM駆動が可能になります。
<ul>
<li>モーターの回転速度も PWM で制御できるので加速や減速などを行う事も可能です。</li>
<li>動作させる前にモーターがジャンパーワイヤー等の他の物を巻き込まない様に注意してください。</li>
<li>電池は USB DIP を使用してモバイルバッテリーに変える事も可能です。</li>
</ul>
</li>
</ul>
<h2 id="参考モバイルバッテリーの利用方法"><a class="header" href="#参考モバイルバッテリーの利用方法">（参考）モバイルバッテリーの利用方法</a></h2>
<img src="./imgs/mobilebattery.jpg" width=500>
<ul>
<li>microUSB DIP化キットを使用してモバイルバッテリーを電池ボックスとして使用する事が出来ます。</li>
<li>電源として利用するだけであれば、VIN と GND の 2ヶ所にジャンパーワイヤーを使用して接続が出来ます。</li>
</ul>
<p><a href="./chapter_8-1.html">応用センサー一覧に戻る</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="818-raspberrypi-のカメラに関する注意"><a class="header" href="#818-raspberrypi-のカメラに関する注意">8.1.8 RaspberryPi のカメラに関する注意</a></h1>
<p><img src="./imgs/PiZero_camera1.jpg" width=300>　<img src="./imgs/PiZero_camera2.jpg" width=300></p>
<ul>
<li>接続端子・フラットケーブルは壊れやすい
<ul>
<li>無理に引っ張らない</li>
<li>折り曲げない様に注意</li>
</ul>
</li>
<li>カメラ接続確認のコマンド</li>
</ul>
<pre><code>$ vcgencmd get_camera
supported=1 detected=1, libcamera interfaces=0
</code></pre>
<ul>
<li>detected=1 と表示されていたら正しく接続が出来ています。</li>
</ul>
<p><a href="./chapter_8-1.html">応用センサー一覧に戻る</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="9-付録"><a class="header" href="#9-付録">9. 付録</a></h1>
<h2 id="予備知識"><a class="header" href="#予備知識">予備知識</a></h2>
<p>CHIRIMEN for Raspberry Pi を利用するに際して、知っておくと良い予備知識やツールの使い方が学べるドキュメントです。</p>
<ul>
<li><a href="https://github.com/webiotmakers/github-handson">GitHub ハンズオン</a>
<ul>
<li>GitHub の基本的な使い方の分かるハンズオン資料です。</li>
</ul>
</li>
<li><a href="https://csb-jp.github.io/">CodeSandbox ガイド</a>
<ul>
<li>ブラウザ上で開発する CodeSandbox の使い方を確認しましょう。</li>
</ul>
</li>
<li><a href="/js/">JavaScript 初学者向け資料集</a>
<ul>
<li>JavaScript 1 Day 講習資料、JavaScript 本格入門書、チートシートなどはこちら</li>
</ul>
</li>
</ul>
<p>その他、電子工作など一般的な知識は <a href="../reference.html">予備知識・資料集</a> や、<a href="../chirimenGeneric/">共通資料集</a>を参照してください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="91-chirimen-ブラウザー版との差異"><a class="header" href="#91-chirimen-ブラウザー版との差異">9.1 CHIRIMEN ブラウザー版との差異</a></h1>
<div class="table-wrapper"><table><thead><tr><th>CHIRIMEN ブラウザー版</th><th>Node.js</th></tr></thead><tbody>
<tr><td>ライブラリ、ドライバーはhtmlで読み込む</td><td>jsの中で直接読み込む</td></tr>
<tr><td><pre><code>&lt;script src="polyfill.js"&gt;&lt;/script &gt;</code></pre></td><td><pre><code>import {requestGPIOAccess} from "./node_modules/node-web-gpio/dist/index.js";</code></pre><br><pre><code>import {requestI2CAccess} from "./node_modules/node-web-i2c/index.js";</code></pre></td></tr>
<tr><td><pre><code>&lt;script src="..../adt7410.js"&gt;&lt;/script &gt;</code></pre></td><td><pre><code>import ADT7410 from "@chirimen/adt7410";</code></pre></td></tr>
<tr><td></td><td>Sleep関数を宣言する<br><pre><code>const sleep = msec =&gt; new Promise(resolve =&gt; setTimeout(resolve, msec));</code></pre></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="92-chirimen環境の任意のディレクトリへのセットアップ"><a class="header" href="#92-chirimen環境の任意のディレクトリへのセットアップ">9.2 CHIRIMEN環境の任意のディレクトリへのセットアップ</a></h1>
<p>以下のコマンド手順で~/myAppディレクトリ以外にも設定できます。</p>
<ul>
<li><code>mkdir [自分用の作業ディレクトリ]</code>  (<a href="https://atmarkit.itmedia.co.jp/ait/articles/1606/07/news015.html">mkdir</a> コマンドとは)</li>
<li><code>cd [自分用の作業ディレクトリ]</code> (<a href="https://atmarkit.itmedia.co.jp/ait/articles/1712/14/news021.html">cd</a>コマンドとは)</li>
<li><code>wget https://tutorial.chirimen.org/pizero/package.json</code> (<a href="https://atmarkit.itmedia.co.jp/ait/articles/1606/20/news024.html">wget</a>コマンドとは)</li>
<li><code>wget https://chirimen.org/remote-connection/js/beta/RelayServer.js</code> (<a href="https://chirimen.org/remote-connection/">RelayServer.js</a>を使う場合)</li>
<li><code>npm install</code> (<a href="https://atmarkit.itmedia.co.jp/ait/articles/1606/17/news030.html">npm</a>とは)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="10-共通資料集"><a class="header" href="#10-共通資料集">10. 共通資料集</a></h1>
<p>CHIRIMEN for PiZero チュートリアルで使われている用語集です。チュートリアルの解説よりも踏み込んだ解説をしています。</br>
初めて CHIRIMEN を触る方は知らなくても利用可能な情報が大半ですが、より深く IoT開発を学びたい方はこちらに掲載された情報も目を通してみてください。</br>
（チュートリアルの各ページからリンクでこちらの情報を参照しています）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="101-chirimen"><a class="header" href="#101-chirimen">10.1 CHIRIMEN</a></h1>
<p><img src="./imgs/CHIRIMEN_pf.png" alt="" />
CHIRIMEN とは、Webの標準的な技術・ブラウザやNode.js等で実行できるJavaScript で電子パーツを制御し、<a href="https://www.iizuka.kyutech.ac.jp/faculty/physicalcomputing">フィジカルコンピューティング</a>や<a href="./chapter_10-6.html">IoTシステム</a>を開発可能なプロトタイピング環境です。</p>
<p>デジタルのソフトとフィジカルなハードをWWW上で連携するデバイスを Web標準技術、JavaScript だけで容易に実現できます。</p>
<h2 id="chirimenについて"><a class="header" href="#chirimenについて">CHIRIMENについて</a></h2>
<ul>
<li><a href="https://tutorial.chirimen.org/about.html">こちらを参照ください</a></li>
</ul>
<h2 id="chirimenのメリット"><a class="header" href="#chirimenのメリット">CHIRIMENのメリット</a></h2>
<ul>
<li>広く使われている標準技術を学習できるので
<ul>
<li>学習のハードルが低い</li>
<li>得たスキルが広く長く役立つ</li>
<li>インターネットでノウハウを検索しやすい</li>
</ul>
</li>
<li>Web技術を活用するので
<ul>
<li>WWWのサービスと簡単に連携できる</li>
<li>ユーザーインターフェースやコンテンツを簡単に作れる</li>
<li>Webブラウザを使って開発できる</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="102-ハードウェアデバイス"><a class="header" href="#102-ハードウェアデバイス">10.2 ハードウェア・デバイス</a></h1>
<ul>
<li><a href="https://tutorial.chirimen.org/reference#section-1">予備知識・資料集～電子工作について</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1021-led"><a class="header" href="#1021-led">10.2.1 LED</a></h1>
<ul>
<li><a href="https://ja.wikipedia.org/wiki/%E7%99%BA%E5%85%89%E3%83%80%E3%82%A4%E3%82%AA%E3%83%BC%E3%83%89">LED（発光ダイオード）</a></li>
<li><a href="https://www.marutsu.co.jp/pc/static/large_order/led">LED の使い方</a></li>
</ul>
<h2 id="ヒント-led-の電圧"><a class="header" href="#ヒント-led-の電圧">ヒント: LED の電圧</a></h2>
<p>LED の順方向電圧は色により異なっており、赤色 LED は 1.8V 程度、青色 LED は 3.1V 程度とされています。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1022-レッドボード"><a class="header" href="#1022-レッドボード">10.2.2 レッドボード</a></h1>
<ul>
<li><a href="https://shop.sunhayato.co.jp/blogs/problem-solving/breadboard">ブレッドボードの使い方</a> (サンハヤト社)</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>外観</th><th>内部の接続状態</th></tr></thead><tbody>
<tr><td><img src="./imgs/breadboardImg.jpg" alt="外観" /></td><td><img src="./imgs/breadboardSch.png" alt="内部の接続状態" /></td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>+と-のライン(上下の横のピン列)が無いブレッドボードもあります（CHIRIMEN Starter Kitのブレッドボードにはありません）</p>
</li>
<li>
<p>配線に使うケーブルの色に厳密な決まりはありませんが、一般的にGNDは黒(や黒っぽい色)、電源(VCC, +3.3V, +5V)には赤(や赤っぽい色)が用いられます。配線間違いを防ぐためにもなるべく合わせましょう。</p>
</li>
<li>
<p>抵抗やLEDの足(リード線)は手で簡単に曲げられます。ブレッドボードに差し込めるように適当に成型してください。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1023-抵抗値の読み方"><a class="header" href="#1023-抵抗値の読み方">10.2.3 抵抗値の読み方</a></h1>
<ul>
<li><a href="http://www.jarl.org/Japanese/7_Technical/lib1/teikou.htm">抵抗値の読み方</a></li>
<li><a href="http://startelc.com/elcLink/tester/elc_nArtcTester2.html#chapter-2">テスターを使って抵抗値を確かめる</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1024-mosfetによる大電力制御"><a class="header" href="#1024-mosfetによる大電力制御">10.2.4 MOSFETによる大電力制御</a></h1>
<h2 id="gpio-の制約事項"><a class="header" href="#gpio-の制約事項">GPIO の制約事項</a></h2>
<p>Raspberry Pi の GPIO ポートは、全体で流せる電流の上限が決められています。</p>
<ul>
<li><a href="https://elinux.org/RPi_Low-level_peripherals#Power_pins">合計 50mA</a></li>
<li>3.3 V</li>
</ul>
<p>小さな LED 数個の場合はこの条件内で使えますが、モーターやソレノイド、パワー LED など電流を多く消費するデバイスは直接接続して使うことができません。</p>
<h2 id="mosfet-とは"><a class="header" href="#mosfet-とは">MOSFET とは</a></h2>
<p><a href="https://ja.wikipedia.org/wiki/MOSFET">MOSFET</a> とは<a href="https://ja.wikipedia.org/wiki/%E9%9B%BB%E7%95%8C%E5%8A%B9%E6%9E%9C%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B8%E3%82%B9%E3%82%BF">電界効果トランジスタ (FET)</a> の一種で、主にスイッチング素子として利用される (小さな電圧の変更で大きな電流・電圧のオンオフを切り替える) 部品です。</p>
<p>今回は Nch MOSFET「<a href="http://akizukidenshi.com/catalog/g/gI-07597/">2SK4017</a>」を利用します。</p>
<p><img src="./imgs/mosfet.png" alt="MOSFET" /></p>
<p>プルダウンの GPIO ポートを使った典型的な回路は以下のようになります。</p>
<p><img src="./imgs/DC3motor-schematic.svg" alt="NCh MOSFET schematic" /></p>
<h2 id="電源"><a class="header" href="#電源">電源</a></h2>
<p>図の GND 端子は Raspberry Pi と DC 負荷用電源のものと共通ですが、VCC 端子は、基本的には Raspberry Pi の 3.3V や 5V 端子とは異なります。
DC 負荷用に Raspberry Pi とは別に電源を用意するのが望ましいです。</p>
<p><a href="./chapter_4-2.html">ミニモータを使った作例</a>では、その消費電力が十分小さいので、例外的に Raspberry Pi の 5V 端子か電力を供給しています。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="103-javascript"><a class="header" href="#103-javascript">10.3 JavaScript</a></h1>
<p>標準化されたプログラミング言語の一種で、ウェブブラウザが代表的な実行環境です(プログラムコードを解釈して動作させるシステム)。CHIRIMENでもRasberry Pi及びmicro:bit版はウェブブラウザを実行環境として使用します。Raspberry Pi Zero版はNode.jsを実行環境として使っています。
別名としてECMA Scriptと呼ばれることもあります。</p>
<ul>
<li><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript">Mozilla Developer Networkの解説</a></li>
</ul>
<h2 id="javascript-の基礎"><a class="header" href="#javascript-の基礎">JavaScript の基礎</a></h2>
<p>JavaScript に慣れていない人は、<a href="https://tutorial.chirimen.org/js/">「JavaScript 初学者向け資料集」</a>を参考にしてください。</p>
<ul>
<li>その他の情報：<a href="https://tutorial.chirimen.org/reference#javascript">予備知識・資料集の情報</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1031-javascriptコードライブラリの読み込み"><a class="header" href="#1031-javascriptコードライブラリの読み込み">10.3.1 JavaScriptコード・ライブラリの読み込み</a></h1>
<h2 id="ウェブアプリhtmlで読み込み"><a class="header" href="#ウェブアプリhtmlで読み込み">ウェブアプリ：HTMLで読み込み</a></h2>
<p>Raspberry Pi Zero 版以外の CHIRIMEN はプログラムの起点はHTMLファイルです。（<a href="https://ja.wikipedia.org/wiki/%E3%82%A6%E3%82%A7%E3%83%96%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3">ウェブアプリ</a>）ブラウザはまずHTMLファイルを読み込んだうえで、そこに書かれた内容で動きます。したがって作ったコードや必要なライブラリの読み込みは基本的に全てこのHTMLの中で指定します。（なお、javascript Moduleを有効化している場合は JavaScriptコードの中で jsライブラリを読み込むことがある）</p>
<p>ポイントは <code>&lt;script ...&gt;&lt;/script&gt;</code> の部分です。
<code>polyfill.js</code> という JavaScript ライブラリを読み込んでいます。これは <a href="http://browserobo.github.io/WebGPIO">Web GPIO API</a> と、<a href="http://browserobo.github.io/WebI2C">Web I2C API</a> という W3C でドラフト提案中の 2 つの API への <a href="https://developer.mozilla.org/ja/docs/Glossary/Polyfill">Polyfill (新しい API を未実装のブラウザでも同じコードが書けるようにするためのライブラリ)</a> で、最初に読み込むとそれ以降のコードで GPIO や I2C を操作する JavaScript API が使えるようになります。</p>
<p>次の行にある <code>main.js</code> は、JavaScript のプログラム本体です。</p>
<h3 id="nodejs-chirimen-raspberry-pi-zero版"><a class="header" href="#nodejs-chirimen-raspberry-pi-zero版">Node.js (CHIRIMEN Raspberry Pi Zero版)</a></h3>
<p>Raspberry Pi Zero版はプログラムの起点が自分が作ったjavascriptコード自体になります。ブラウザの代わりに<a href="https://ja.wikipedia.org/wiki/Node.js">Node.js</a>というJavaScriptコードだけを解釈するソフト（JavaScript <a href="https://ja.wikipedia.org/wiki/%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%97%E3%83%AA%E3%82%BF">インタープリタ</a>）にコードを読み込ませて実行します。</p>
<p>CHIRIMEN環境のために必要なライブラリや、<a href="chapter_10-3-1.html#WebI2C%E3%81%A8%E3%83%87%E3%83%90%E3%82%A4%E3%82%B9%E3%83%89%E3%83%A9%E3%82%A4%E3%83%90">I2Cデバイスのドライバ</a>(後述)は次の ECMA Script Module という仕組みを使って読み込みます。</p>
<h3 id="javascript-module-ecma-script-module"><a class="header" href="#javascript-module-ecma-script-module">JavaScript Module (ECMA Script Module)</a></h3>
<ul>
<li>ウェブアプリでのModule有効化：HTMLのscript要素でjavascriptを読み込むとき、ttype="module"プロパティを設定する。
<ul>
<li><code>&lt;script type="module" src="main.js"&gt;&lt;/script&gt;</code></li>
</ul>
</li>
<li>import文で外部のライブラリを読み込む。
<ul>
<li><code>import {RelayServer} from "https://chirimen.org/remote-connection/js/beta/RelayServer.js";</code></li>
</ul>
</li>
<li>importされるライブラリ側には、importできるオブジェクトを指定するexport文を記述する。</li>
<li><code>export {RelayServer};</code></li>
<li><a href="https://codesandbox.io/s/github/chirimen-oh/chirimen.org/tree/master/pizero/esm-examples/remote_gpio_led/pc">例を見てみる</a></li>
<li><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Modules">Mozilla Developer Networkの解説</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1032-非同期処理"><a class="header" href="#1032-非同期処理">10.3.2 非同期処理</a></h1>
<p>物理デバイス制御やネットワーク通信などでは、応答待ち中にブラウザが停止しないよう非同期処理を使う必要があります。
本チュートリアルではこれを <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/async_function">async 関数</a> で記述しています。async 関数による非同期処理に慣れていない人は、<a href="https://tutorial.chirimen.org/js/async.html">こちらの資料「非同期処理 (async await 版)」</a> も参考にしてください。非同期処理についてより詳しくは <a href="https://jsprimer.net/basic/async/">JS Primer の非同期処理説明ページ</a> をご覧ください。</p>
<p>非同期処理を使いこなすのは難しいですが、本チュートリアルでは次のルールでコードを書けば大丈夫です:</p>
<ul>
<li><strong>非同期関数の呼び出し時には前に <code>await</code> を付けて呼び出す</strong>
<ul>
<li>非同期関数呼び出し前に <code>await</code> を付けると、その処理の完了を待ってから次のコードが実行されます</li>
<li>GPIO/I2C の初期化、ポートの設定などは非同期処理なので <code>await</code> キーワードを付けて呼び出します</li>
</ul>
</li>
<li><strong>非同期処理を含む関数は前に <code>async</code> を付けて非同期関数として定義する</strong>
<ul>
<li><code>async function 関数名() { ... }</code> のように頭に <code>async</code> を付けるだけで非同期関数になります</li>
</ul>
</li>
</ul>
<p>非同期関数を <code>await</code> なしで呼び出すと返り値が Promise オブジェクトとなり、Promise を理解しないと返り値の判断や実行順序が入れ替わり意図せぬ挙動になります。例えば、ポートの初期化を <code>await</code> なしで呼ぶと、ポート初期化前に初期化未完了のハードウェアを操作しようとして失敗したりします。</p>
<p>ハードウェアを制御するときは基本的に非同期呼び出しをする (その処理を含む関数もまた非同期で呼びす) と決めておけば迷うことなく、コードの実行順序も上から下に見たとおりの順番で実行され読み書きしやすくなります。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="104-gpio"><a class="header" href="#104-gpio">10.4 GPIO</a></h1>
<h2 id="gpioとは"><a class="header" href="#gpioとは">GPIOとは</a></h2>
<p><a href="https://ja.wikipedia.org/wiki/GPIO">GPIO</a>は、「General-purpose input/output」の略で汎用的な入出力インタフェースのことです。</p>
<p>Raspi に実装されている 40 本のピンヘッダから GPIO を利用することができます。</p>
<p>CHIRIMEN Raspi、Raspi Zero では Raspi が提供する 40 本のピンヘッダのうち、下記緑色のピン(合計 17 本)が利用可能です。CHIRIMEN micro:bitでは<a href="https://chirimen.org/chirimen-micro-bit/guidebooks/diff_rpi3.html#%E4%BD%BF%E7%94%A8%E3%81%A7%E3%81%8D%E3%82%8Bgpio%E3%83%9D%E3%83%BC%E3%83%88">こちらのページ</a>に記載されている端子が利用可能です。</p>
<p>Raspiやmicro:bit の GPIO 端子は、GND 端子との間に、0V もしくは 3.3V の電圧を印加(出力)したり、逆に 0V もしくは 3.3V の電圧を検知(入力)したりすることができます。LED は数 mA の電流を流すことによって点灯できる電子部品のため、印加する電圧を 3.3V(点灯)、0V(消灯) と変化させることで L チカが実現できるのです。</p>
<p>詳しくは<a href="https://tool-lab.com/make/raspberrypi-startup-22/">こちらのサイトの解説</a>などを参考にしてみましょう。</p>
<h3 id="raspberry-piのピン配置図"><a class="header" href="#raspberry-piのピン配置図">Raspberry Piのピン配置図</a></h3>
<p><img src="https://chirimen.org/PiZeroWebSerialConsole/wallpaperS.png" alt="Raspi PIN配置図" /></p>
<!--
![Raspi PIN配置図](../raspi/imgs/section0/Raspi3PIN.png)
{% cloudinary ../raspi/imgs/section0/Raspi3PIN.png alt="Raspi PIN配置図" %}
-->
<h3 id="raspverry-pi-zeroのピン配置図"><a class="header" href="#raspverry-pi-zeroのピン配置図">Raspverry Pi Zeroのピン配置図</a></h3>
<p>Raspberry Piの端子と同じ配列です。</p>
<h3 id="microbitのピン配置図"><a class="header" href="#microbitのピン配置図">micro:bitのピン配置図</a></h3>
<p><img src="https://tech.microbit.org/docs/hardware/assets/edge_connector.svg" alt="micro:bitのI端子" /></p>
<h3 id="プルアップpuプルダウンpd"><a class="header" href="#プルアップpuプルダウンpd">プルアップ(PU)、プルダウン(PD)</a></h3>
<p>GPIOポートを入力モードで使用する場合、ポートが解放状態(電気的に切り離されている状態)のときに設定される値があります。
プルアップは1、プルダウンは0になります。　Raspberry Piのピン配置図に書かれているPU,PDがその設定値です。micro:bitではすべてプルダウンに設定されていますが、GPIOポート初期化時にプルアップに設定することもできます。</p>
<ul>
<li><a href="https://voltechno.com/blog/pullup-pulldown/">より詳しく知る(voltechno)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1041-gpioポートの初期化と出力処理"><a class="header" href="#1041-gpioポートの初期化と出力処理">10.4.1 GPIOポートの初期化と出力処理</a></h1>
<h2 id="gpioポートの初期化"><a class="header" href="#gpioポートの初期化">GPIOポートの初期化</a></h2>
<p>今回の JavaScript ファイルで、最初に呼び出されるコードは <code>await navigator.requestGPIOAccess()</code> です。
ここで先ほど出て来た <a href="http://browserobo.github.io/WebGPIO">Web GPIO API</a> を使い、<code>gpioAccess</code> という GPIO にアクセスするためのインタフェースを取得しています。</p>
<pre><code class="language-js">  const gpioAccess = await navigator.requestGPIOAccess(); // GPIO を操作する
</code></pre>
<p><strong>関数の呼び出しに <code>await</code> 接頭詞を付けることに注意してください。</strong> この関数は非同期関数で、その処理の完了を待ってから次の処理をする必要があります。また、<code>await</code> 接頭詞を使うコードを含むために、それを含む関数 <code>main()</code> は async 接頭詞付きの非同期関数として定義する必要があります。</p>
<h2 id="gpioport-の出力処理"><a class="header" href="#gpioport-の出力処理">GPIOPort の出力処理</a></h2>
<p>GPIOの<strong>出力</strong>機能を使います。
<strong><code>const port = gpioAccess.ports.get(26)</code> で GPIO の 26 番ポートにアクセスするためのオブジェクト</strong> を取得しています。</p>
<pre><code class="language-js">  const port = gpioAccess.ports.get(26); // 26 番ポートを操作する
</code></pre>
<p>続いて、 <strong><code>await port.export("out")</code> で GPIO の 26 番を「出力設定」にしています</strong>。これにより LED への電圧の切り替えが可能になっています。</p>
<pre><code class="language-js">  await port.export("out"); // ポートを出力モードに設定
</code></pre>
<p>最後に、無限ループのなかで <code>await sleep(1000)</code> によって 1000 ms (1 秒) 待機さ 1 秒ごとに <code>await port.write(1)</code> と <code>await port.write(0)</code> を交互に呼び出し、GPIO 26 番に加える電圧を 3.3V → 0V → 3.3V → 0V → … と繰り返しています。</p>
<pre><code class="language-js">  // 無限ループ
  while (true) {
    // 1秒間隔で LED が点滅します。
    await port.write(1); // LED を点灯
    await sleep(1000); // 1000 ms (1秒) 待機
    await port.write(0); // LED を消灯
    await sleep(1000); // 1000 ms (1秒) 待機
  }
</code></pre>
<p>LED は一定以上の電圧を加え、電流を流すと点灯する性質を持っています。
つまり、3.3 V を加えたとき点灯し、0 V を加えたとき消灯、これを繰り返すことになります。</p>
<h3 id="サンプルコードを編集してみよう"><a class="header" href="#サンプルコードを編集してみよう">サンプルコードを編集してみよう</a></h3>
<ul>
<li>点滅周期を早く・遅く (<code>sleep()</code>の引数を変更)</li>
<li>点灯する時間と消灯する時間を変える (同上)</li>
<li>GPIO ポートを他のポートに変える・配線を変える (<code>gpioAccess.ports.get</code>の引数を変更)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1042-gpioportの入力処理onchange"><a class="header" href="#1042-gpioportの入力処理onchange">10.4.2 GPIOPortの入力処理（onchange）</a></h1>
<p>GPIOポートに繋いだスイッチやセンサーの状態を取得するには、GPIOの<strong>入力</strong>機能を使います。出力とは違って入力は二つの方法があります。onchangeとポーリングの二つの方法があります。</p>
<h2 id="onchange編"><a class="header" href="#onchange編">onchange編</a></h2>
<p>GPIOポートの値が変化するたびに、指定した関数が実行されます。</p>
<pre><code class="language-js">async function main() {
  const button = document.getElementById("button");
  const ledView = document.getElementById("ledView");
  const gpioAccess = await navigator.requestGPIOAccess();
  const ledPort = gpioAccess.ports.get(26); // LED の GPIO ポート番号
  await ledPort.export("out");
  const switchPort = gpioAccess.ports.get(5); // タクトスイッチの GPIO ポート番号
  await switchPort.export("in");

  async function light(lit) {
    await ledPort.write(lit ? 1 : 0);
    const color = lit ? "red" : "black";
    ledView.style.backgroundColor = color;
  }

  button.onmousedown = async function() {
    await light(true);
  };

  button.onmouseup = async function() {
    await light(false);
  };

  // Pull-up なので押したとき 0、それ以外では 1 が得られる
  switchPort.onchange = async function(state) {
    const lit = state === 0;
    await light(lit);
  };
}

main();
</code></pre>
<p><code>port.onchange</code> は <strong>入力モードの GPIO ポートの「状態変化時に呼び出される関数を設定する」</strong> 機能です。このような関数のことをコールバック関数と呼びます。下記の<code>port.read()</code> を使ったコードと異なりポーリング処理が不要でコードも簡潔ですが、値が変化したタイミング以外では読み取りができませんのでユースケースが少し限られます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1043-gpioportの入力処理ポーリング"><a class="header" href="#1043-gpioportの入力処理ポーリング">10.4.3 GPIOPortの入力処理（ポーリング）</a></h1>
<h3 id="単純入力ポーリング"><a class="header" href="#単純入力ポーリング">単純入力＋ポーリング</a></h3>
<p>こちらはGPIOポートの入力値を一回きり単発で取得する単純入力機能と、ポーリングの組み合わせです。</p>
<h4 id="ポーリングとは"><a class="header" href="#ポーリングとは">ポーリングとは</a></h4>
<p>様々な情報や値の取得や入力のための基本的な機能・関数は、入力を指定した瞬間、一回きり取得するだけのものがほとんどです。そこで、無限ループをつくりこの中で一回きりの入力を定期的に繰り返すことで、入力の変化を読み取る　ということがよく行われます。このような処理を一般にポーリングと呼びます。 (<a href="https://ja.wikipedia.org/wiki/%E3%83%9D%E3%83%BC%E3%83%AA%E3%83%B3%E3%82%B0_(%E6%83%85%E5%A0%B1)">wikipedia:ポーリング</a>)
ポーリングはセンサーの情報入力だけでなく、たとえば電子メールの到着を通知するために定期的にメールサーバにメール着信数を確認する　といった、ネットワークサービスでの処理など様々なシステムで広く使われています。</p>
<h4 id="gpioの単純入力関数"><a class="header" href="#gpioの単純入力関数">GPIOの単純入力関数</a></h4>
<p>単純に「GPIO ポートの状態を読み込む」には <code>port.read()</code> を使います。</p>
<p><code>port.read()</code> で GPIO を読み込むコードは次のように書けます:</p>
<pre><code class="language-js">const gpioAccess = await navigator.requestGPIOAccess();
const switchPort = gpioAccess.ports.get(5); // GPIO ポート 5 番を取得
await switchPort.export("in"); // 「入力モード」に
const state = await switchPort.read(); // GPIO ポート 5 番に接続したスイッチの状態を読み込む
</code></pre>
<h5 id="await-portexport"><a class="header" href="#await-portexport">await port.export()</a></h5>
<p><code>port.export("in")</code> により取得した <strong>GPIO ポートを「入力モード」で初期化</strong> しています。このモードは GPIO ポートにかかる電圧を Web アプリ側から読み取りたい時に使います。初期化は非同期処理であり <code>await</code> で完了を待つ必要があることに注意してください。</p>
<h5 id="await-portread"><a class="header" href="#await-portread">await port.read()</a></h5>
<p><code>port.export("in")</code> で入力モードに設定した <strong>GPIO ポートの現時点の状態を読み取ります</strong>。読み取りは非同期処理になるので <code>await</code> で完了を待つようにしてください。</p>
<h5 id="ポーリングルーチン"><a class="header" href="#ポーリングルーチン">ポーリングルーチン</a></h5>
<p>上記コードで GPIO ポートの読み取りを 1 度だけ行えますが、今回は「スイッチが押され状態を監視する」必要がありますので、定期的に <code>await port.read()</code> を繰り返して GPIO ポートの状態を監視するポーリングのルーチンを組みます。</p>
<pre><code class="language-js">const gpioAccess = await navigator.requestGPIOAccess();
const switchPort = gpioAccess.ports.get(5);
await switchPort.export("in");
// 無限ループ
while (true) {
  const state = await switchPort.read(); /
  //
  // ここにswitchの状態による処理を書き足す
  //
  await sleep(100); // 100 ms 待機
}

// sleep() は polyfill 内で定義済みなので省略可能:
function sleep(ms) {
  return new Promise(function(resolve) {
    setTimeout(resolve, ms);
  });
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="105-i2c"><a class="header" href="#105-i2c">10.5 I2C</a></h1>
<h2 id="i2cの概要-1"><a class="header" href="#i2cの概要-1">I2Cの概要</a></h2>
<p><a href="https://ja.wikipedia.org/wiki/I2C">I2C</a> とは 2 線式の同期式シリアル通信インタフェースです。「アイ・スクエア・シー」や「アイ・ ツー・シー」と読みます。I2C では SDA（シリアルデータ）と SCL（シリアルクロック）の 2 本の線で通信を行います。</p>
<p><img src="./imgs/i2c-bus.png" alt="i2c-bus" /></p>
<!--
{% cloudinary half ../raspi/imgs/section2/i2c-bus.png alt="i2c-bus" %}
-->
<p>上図のように、I2C の SDA、SCL は複数のデバイス間で共有され、これを「I2C バス」と言います。I2C ではマスターとスレーブの間で通信が行われます。常にマスター側からスレーブ側に要求が行われ、スレーブ側からマスター側へ要求を行うことはできません。</p>
<p>本チュートリアルでいえばCHIRIMEN環境を動かすボードコンピュータがマスターとなり、ここに接続されるセンサーやアクチュエータデバイスなどがスレーブとして想定されます。スレーブデバイスの一例として<a href="../partslist">こちらに紹介</a>されているI2Cデバイスをご覧ください。</p>
<p>マスターは、スレーブが持つ「SlaveAddress (スレーブアドレス)」を指定して、特定のスレーブとの通信を行います。このため、同じ I2C バス上に同じ SlaveAddress のスレーブを繋ぐことはできません。
I2Cデバイスは小型のICチップデバイスとなっており、デバイスによってはSlaveAddressは製品ごとに固定されています。</p>
<p><img src="./imgs/i2c-bus2.png" alt="i2c-bus2" /></p>
<p>通信するデバイス同士が同一基板上にない場合には、SDA、SCL の 2 本の通信線に加え電源や GND の線を加えて 4 本のケーブルを用いて接続するのが一般的です。電源電圧はデバイスに応じたものを繋ぐ必要があります。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1051-各種ボードの-i2c端子について"><a class="header" href="#1051-各種ボードの-i2c端子について">10.5.1 各種ボードの I2C端子について</a></h1>
<h3 id="raspberry-pi-の-i2c端子-1"><a class="header" href="#raspberry-pi-の-i2c端子-1">Raspberry Pi の I2C端子</a></h3>
<p>下図のSCL, SDAがI2C端子です（黄色の端子）</p>
<p><img src="./imgs/Raspi3PIN.png" alt="Raspi PIN配置図" /></p>
<h3 id="raspverry-pi-zero-の-i2c端子"><a class="header" href="#raspverry-pi-zero-の-i2c端子">Raspverry Pi Zero の I2C端子</a></h3>
<p>Raspberry PiのI2C端子と同じ配列です。</p>
<h3 id="microbit-の-i2c端子"><a class="header" href="#microbit-の-i2c端子">micro:bit の I2C端子</a></h3>
<p>下図のSCL, SDAがI2C端子です (P19,P20～オレンジ色I2C1のグループ)
<img src="https://tech.microbit.org/docs/hardware/assets/edge_connector.svg" alt="micro:bitのI端子" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1052-i2cの詳細情報とポイント"><a class="header" href="#1052-i2cの詳細情報とポイント">10.5.2 I2Cの詳細情報とポイント</a></h1>
<h2 id="参考-i2c-に関する詳細情報"><a class="header" href="#参考-i2c-に関する詳細情報">参考: I2C に関する詳細情報</a></h2>
<p>I2C に関する詳細は下記をご確認ください。</p>
<ul>
<li><a href="https://ja.wikipedia.org/wiki/I2C">I2C</a> - Wikipedia</li>
<li>I2C バス仕様書 最新版（<a href="https://www.nxp.com/docs/ja/user-guide/UM10204.pdf">日本語</a>、<a href="http://www.nxp.com/documents/user_manual/UM10204.pdf">English</a>）</li>
<li><a href="http://www.picfun.com/i2cframe.html">I2C の使い方</a>（後閑哲也氏サイト)</li>
</ul>
<h2 id="ポイント-1"><a class="header" href="#ポイント-1">ポイント</a></h2>
<p>I2C の概要として下記を押さえておきましょう。</p>
<ul>
<li>I2C バスを介して複数のデバイスが繋がる</li>
<li>I2C デバイスにはマスターとスレーブがある</li>
<li>I2C ではマスターからスレーブに対して通信要求が行われる</li>
<li>I2C スレーブは SlaveAddress を持つ</li>
<li>同じ I2C バスに同じ SlaveAddress のデバイスは繋げない</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1053-webi2c-とデバイスドライバ"><a class="header" href="#1053-webi2c-とデバイスドライバ">10.5.3 WebI2C とデバイスドライバ</a></h1>
<p>CHIRIMENでは、GPIOインターフェースをWeb GPIOと呼ぶAPIで使用しました。I2Cインターフェースに接続されたスレーブデバイスは<a href="http://browserobo.github.io/WebI2C">Web I2C API</a>と呼ぶAPIによって使用することができます。</p>
<p>しかしI2CスレーブデバイスはGPIOの先に繋げるデバイスと比べてずっと複雑な機能を持っています。実際にはそれは極小のコンピュータで、I2Cを通しデバイス専用のコマンドやデータを送受信（通信）し、固有の機能を利用します。
このようなコードは、各デバイスのデータシートをよく読み込んだうえで書くことができます。これはかなり手間のかかる開発ですので簡単にデバイスが使用できるライブラリ(デバイスドライバ)があらかじめ用意されています。</p>
<h3 id="デバイスドライバが用意されているi2cデバイスのリスト"><a class="header" href="#デバイスドライバが用意されているi2cデバイスのリスト">デバイスドライバが用意されているI2Cデバイスのリスト</a></h3>
<p><a href="https://tutorial.chirimen.org/partslist#i2c-">デバイスドライバが用意され簡単に利用できるI2Cデバイスのリスト</a></p>
<p>よく利用される、30種類ぐらいの比較的安価なデバイス向けのドライバが用意されています。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="106-iot"><a class="header" href="#106-iot">10.6 IoT</a></h1>
<p>これまでのチュートリアルでは、いずれもそのコンピュータに直接接続されたデバイスを使うものでした。このようなシステムは「スタンドアロン」と呼ばれます。
今までは、ウェブブラウザを使っていたのに、実はウェブの重要な機能～インターネット上の情報基盤 WWW を活用したシステムを作っていなかったのです。（開発環境としては GitHub や CodeSandbox など WWW上の情報サービスを活用していますが）</p>
<p>このようなインターネットを活用するシステムのことを IoT (Internet of Thing の略)と呼びます。ただし単に PC やスマホで使うウェブサービスが IoT と呼ばれることがありません。チュートリアルで学んだようなセンサーやアクチュエータがシステムに組み込まれ、物理的なモノと相互作用するようなものを特に IoT と呼びます。（なお、WWW を用いずネットワーク部のインターネットだけを使ったものでも IoT と呼びます。詳しくは <a href="https://ja.wikipedia.org/wiki/%E3%83%A2%E3%83%8E%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%8D%E3%83%83%E3%83%88">wiki</a> や、<a href="https://smartiot-forum.jp/application/files/5315/8642/5503/iot-jinzai-text_verR0202.pdf">こちらの資料</a>なども参考にしてください）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1061-websocketとpubsub-services"><a class="header" href="#1061-websocketとpubsub-services">10.6.1 webSocketとpub/sub services</a></h1>
<h2 id="システム構成"><a class="header" href="#システム構成">システム構成</a></h2>
<p><img src="./imgs/IoTsystemConf.png" alt="sysConfImg" /></p>
<p>今回のチュートリアルでつくるIoTシステムの構成図です。</p>
<p>インターネットを介して、左側のアクチュエータやLEDを右側のウェブアプリから操作したり、
左側でセンシングしたデータを右側のウェブアプリで表示させたりするシステムですね。</p>
<p>構成要素を見ていきます。</p>
<ul>
<li>
<p>左側のボードコンピュータはCHIRIMENを使ったプログラミングで使用してきた環境やデバイスを使います。</p>
</li>
<li>
<p>右側のPCはどんなブラウザでも動かせるので、スマートフォンを使うこともできます。<br>インターネットにつながっていさえすれば別の場所のPCやスマホでも動きます。これがIoTの便利なところ～遠隔操作ですね。</p>
</li>
<li>
<p>InternetのrelayServiceが見慣れないものだと思います。以下で解説します。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1062-relayservice"><a class="header" href="#1062-relayservice">10.6.2 relayService</a></h1>
<p>送り側(左側)のWebAppsが、受け側(右側)のwebAppsに情報を送るなら、直接接続するのが簡単そうです。これはピアツーピア通信と言います。</p>
<p>実はこれは簡単ではありません。webAppsはインターネット上のあらゆるコンピュータ（サーバやブラウザの乗ったPCも含め）にURLでアクセスする必要がありますが、相手のPCにURLでアクセスすることは難しいのです。</p>
<p>一方、(あらかじめ用意されていれば)ウェブサーバにはURLでアクセスできます。そこで登場するのがrelayServerです。下図のようにrelayServer(Web Socket Relay Service)を介してwebAppsが通信します。</p>
<p><img src="https://chirimen.org/remote-connection/imgs/relay.png" alt="Relay Server Configuration" /></p>
<p>relayServerは特定のウェブサイトの固有名ではなく、「ウェブアプリ間でリアルタイム性の高いデータのやり取りを仲介する」という機能を持ったウェブサイトの抽象的な名称で pub/sub services と呼ばれることもあります。（SNSとかblogとかというのと同じです）</p>
<p>relayServer はトークン（ユーザーやシステムごとに割り当てられたランダムな文字列）ごとにスペース（図の濃い青色）が設けられ、その中にいくつかのチャンネル（図の茶色）を置くことができます。</p>
<p>同じトークンとチャンネルにアクセスしたウェブアプリ同士が通信でき、図ではウェブアプリは２個つながっていますが、何個でもつなげることができます。チャットスペースのようなイメージですね。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1063-リアルタイム性"><a class="header" href="#1063-リアルタイム性">10.6.3 リアルタイム性</a></h1>
<p>例えば遠隔からカメラのパンチルトをコントロールしたい　などのケースを考えると、IoTではデバイスのコントロールを機敏に行いたいケースが多くあります。（リアルタイム性の高いユースケースが多い）このようなリアルタイム性の高い情報のやり取りのために<a href="https://ja.wikipedia.org/wiki/WebSocket">WebSocket</a>というブラウザが標準としてサポートするプロトコルがよく使われます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1064-relayserverjs"><a class="header" href="#1064-relayserverjs">10.6.4 relayServer.js</a></h1>
<p>IoT には relayServer の機能を持つウェブサイトが必要になりますが、これを誰かが運営しなければなりません。実習やプロトタイピングのためにこのようなサイトを自分たちで立ち上げるのはかなり大変ですが、インターネット上では既にいくつもの事業者が relayServer サービスを提供しています。</p>
<p>今回は CHIRIMEN環境の試験用に、CHIRIMEN用に用意された検証用サービス(chirimentest)を使うことにしますが、いくつかある事業者間でサービスの内容に差異があります。サイトごとの差異は主に接続できる端末の管理と情報の取り扱いに関する機能になります。</p>
<p><a href="https://chirimen.org/remote-connection/">relayServer.js</a> は、relayServerサービスによる差異を吸収し複数の事業者を自由に切り替えられ、webSocket の標準 API仕様に沿った作法で WebApps(含Node.jsプログラム)間の通信を簡単に使えるようにするライブラリです。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1065-プログラムの流れ"><a class="header" href="#1065-プログラムの流れ">10.6.5 プログラムの流れ</a></h1>
<h2 id="初期化受信側送信側共通の処理"><a class="header" href="#初期化受信側送信側共通の処理">初期化（受信側、送信側共通の処理</a></h2>
<p><a href="https://chirimen.org/remote-connection/#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">詳しくはこちらを参照</a></p>
<pre><code class="language-javascript">import {RelayServer} from "https://chirimen.org/remote-connection/js/beta/RelayServer.js";
var relay = RelayServer("achex", "chirimenSocket" );
</code></pre>
<p>import文でライブラリRelayServer.jsを読み込んだ後、relayServiceのひとつ<strong>achex</strong>に接続しています。
RelayServerの第二引数<code>("chirimenSocket")</code>はそのサービスを使うためのトークンですが、<strong>achex</strong>は任意の文字列で利用できてます。</p>
<p><em>Node.jsでは第三,第四引数が必要になります (後述)</em></p>
<h5 id="チャンネルの作成"><a class="header" href="#チャンネルの作成">チャンネルの作成</a></h5>
<ul>
<li>
<p><code>channel = await relay.subscribe("chirimenMbitSensors");</code></p>
<p>変数<code>channel</code>にRelayServerのチャンネルのインスタンスを登録
引数はチャンネル名で、自分で好きな名前を与えられます。</p>
<p>受信側と送信側で同じサービス、トークン、チャンネルを指定する必要があります。</p>
</li>
</ul>
<h5 id="データの送信"><a class="header" href="#データの送信">データの送信</a></h5>
<ul>
<li>
<p><code>channel.send(data);</code></p>
<p>任意のデータ(data)をrelayServerの指定チャンネルに送信します。</p>
<p>dataは文字列だけでなく、連想配列(構造化されたデータ、オブジェクト)も送信可能です。</p>
</li>
</ul>
<h5 id="データの受信"><a class="header" href="#データの受信">データの受信</a></h5>
<ul>
<li>
<p><code>channel.onmessage = getMessage;</code>
チャンネルにメッセージがポストされた時に起動する関数(コールバック関数)を登録しています。</p>
</li>
<li>
<p><code>function getMessage(msg)</code>
上で登録した関数の第一引数(<code>msg</code>)のメンバ変数msg.dataに送信されたメッセージが構造もそのままで届きます。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1066-セキュリティを考えよう"><a class="header" href="#1066-セキュリティを考えよう">10.6.6 セキュリティを考えよう</a></h1>
<p>relayServerを使うということは、情報をインターネット上のウェブサイトに送信することになります。すると このウェブサイトがその情報をどのように取り扱うのかを理解しておく必要があります。achexは無料で使え　しかもユーザ登録も不要です。つまりこのサイトに送信した情報は誰でも見ることができてしまうということです。（ただし、トークンとチャンネルを知る必要がある。これがachexのセキュリティレベル）今回は個人情報などのセキュリティを考慮する必要がない、チュートリアルで使うセンシングデータを送るだけですので問題ありませんが、セキュリティを考慮する必要がある多くの用途ではそのセキュリティ基準に適合したサイトを契約して利用する、もしくは自分でそのようなサイトを立てるなどの必要が出てきます。relayServer.jsでも<a href="https://chirimen.org/remote-connection/#%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%81%94%E3%81%A8%E3%81%AE%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95">いくつかの商用サイト</a>の比較と使用方法が記載されているので参考にしてください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1067-nodejsでの利用"><a class="header" href="#1067-nodejsでの利用">10.6.7 Node.jsでの利用</a></h1>
<p>初期化手順に差異があります。</p>
<pre><code class="language-javascript">import nodeWebSocketLib from "websocket";
import {RelayServer} from "./RelayServer.js";
var relay = RelayServer("achex", "chirimenSocket" , nodeWebSocketLib, "https://chirimen.org");
</code></pre>
<ul>
<li>Node.jsではwebSocketを使用するためにはwebsocketライブラリが必要なので読み込みます</li>
<li>RelayServer.jsやwebSocket等のライブラリは、ローカルからの読み込みになります</li>
<li>RelayServerの第三引数でwebsocketライブラリを渡す必要があります</li>
<li>RelayServerの第四引数で、<a href="https://e-words.jp/w/%E3%83%AA%E3%83%95%E3%82%A1%E3%83%A9.html">リファラー</a>の指定が必要です
<ul>
<li>webアプリの場合はそのコンテンツの配信元のURLがリファラーとして自動設定されますが、Node.jsのアプリはローカルにあるので別途指定が必要</li>
<li>achexの場合URLは何でも許可されますが、他のrelayServerサービスでは あらかじめ指定したリファラーが設定されていなければアクセス拒否されるものもあります(これも一つのセキュリティ)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1068-webhooks"><a class="header" href="#1068-webhooks">10.6.8 Webhooks</a></h1>
<p>relayServer が必要なほどリアルタイム性は求めないけれど、むしろ既存の Webサービス・アプリと簡単につなぎたいようなケースでは、httpをそのまま使うことができるでしょう。ただし既存の Webサービス・アプリはウェブブラウザを介して人が操作することが前提でつくられていますので、直接センサーやアクチュエータ（を制御するコンピュータとプログラム～IoTデバイス）をつなげるにはハードルがあります。</br></p>
<p>IFTTT に代表されるような Webhooksサービスは、http を活用することで既存の多くのウェブサービス（ X（旧twitter） や Google のサービスなど）と IoTデバイスを簡単に接続できるようにする中継サービスです。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1069-iotクラウドサービス"><a class="header" href="#1069-iotクラウドサービス">10.6.9 IoTクラウドサービス</a></h1>
<p>Webhook のような中継サービスを介さずに、直接 IoTデバイスを接続できるように設計されたサービスが多くの事業者から提供されています。これらのサービスを使うには、各サービス事業者ごとに提供している API・プロトコル等の仕様に基づいた開発が必要になります。</p>
<h2 id="w3c-wot-fiware"><a class="header" href="#w3c-wot-fiware">W3C WoT, FIWARE</a></h2>
<p>先述のようなIoT事業者間の非互換を解消するとともに、多様なユースケースにも対応するための国際標準化が現在進行中です。</p>
<ul>
<li><a href="https://www.w3.org/WoT/">WoT</a></li>
<li><a href="https://www.fiware.org/">FIWARE</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/external-links.js"></script>
        <script src="theme/favicon.js"></script>
        <script src="theme/regexp-search.js"></script>
        <script src="theme/sidebar.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
